// str literal type

    struct str {
        data: &*u8,
        size: u32,
    };

// panic

    fn panic(message: str) {
        *(0 as &u32) = 69420; // error indicator
        // TODO: &&*u8 should be parsed fine without a space
        *(4 as & &*u8) = message.data;
        *(8 as &u32) = message.size;
        unreachable;
    };

// alloc

    const alloc::STACK = 0;
    const alloc::HEAP  = 1;

    macro alloc!<T>(alloc_id: u32) -> &T {
        alloc(alloc_id, sizeof T) as &T;
    };

    macro alloc_many!<T>(alloc_id: u32, count: u32) -> &*T {
        alloc(alloc_id, count * sizeof T) as &*T;
    };

    fn alloc(alloc_id: u32, size: u32) -> &() {
        if alloc_id == 0 {
            return stack::alloc(size);
        };

        return heap::alloc(size);
    };

    macro free!<T>(alloc_id: u32, ptr: &T) {
        free(alloc_id, ptr as &(), sizeof T);
    };

    macro free_many!<T>(alloc_id: u32, ptr: &*T, count: u32) {
        free(alloc_id, ptr as &(), count * sizeof T);
    };

    fn free(alloc_id: u32, ptr: &(), size: u32) {
        if alloc_id == 0 {
            return stack::free(size);
        };

        return heap::free(ptr);
    };

// memory instructions

    struct mem {};

    const mem::POINTER_SIZE = 4;
    const mem::PAGE_SIZE = 65536;

    fn mem::align(size: u32) -> u32 {
        return mem::align_to(size, mem::POINTER_SIZE);
    };

    fn mem::align_to(size: u32, size_multiple: u32) -> u32 {
        let remaining_to_align = size % size_multiple;
        if remaining_to_align == 0 {
            return size;
        };

        let padding = size_multiple - remaining_to_align;
        return size + padding;
    };

    // TODO: use builtin mem.copy instr, check engine support
    fn mem::copy(src: &(), dist: &(), size: u32) {
        loop {
            if size == 0 {
                break;
            };

            size -= 1;

            *((dist as u32 + size) as &u8) = *((src as u32 + size) as &u8);
        };
    };

    fn mem::swap(ref1: &(), ref2: &(), size: u32) {
        loop {
            if size == 0 {
                break;
            };

            size -= 1;

            let tmp = *((ref1 as u32 + size) as &u8);
            *((ref1 as u32 + size) as &u8) = *((ref2 as u32 + size) as &u8);
            *((ref2 as u32 + size) as &u8) = tmp;
        };
    };

// stack

    struct stack {};

    let stack::CURRENT = __DATA_SIZE__;
    let stack::BEGIN = __DATA_SIZE__; // TODO: this should be const
    const stack::END = 1_048_576; // 1MB, ~20 pages (65_536b)

    macro stack::alloc!<T>() -> &T {
        stack::alloc(sizeof T) as &T;
    };

    fn stack::alloc(size: u32) -> &() {
        stack::CURRENT += size;

        if stack::CURRENT > stack::END {
            panic("Stack overflow");
        };

        return (stack::CURRENT - size) as &();
    };

    macro stack::free!<T>() {
        stack::free(sizeof T);
    };

    fn stack::free(size: u32) {
        stack::CURRENT -= size;

        if stack::CURRENT < stack::BEGIN {
            panic("Stack underflow");
        };
    };

// heap

    struct heap {};

    struct heap::Block {
        size: u32,
        used: bool,
        next: & heap::Block,
        data: &(),
    };

    let heap::TOTAL_ALLOCATED = stack::END;
    let heap::FIRST_BLOCK = 0 as &heap::Block;
    let heap::CURRENT_BLOCK = 0 as &heap::Block;

    macro heap::alloc_many!<T>(count: u32) -> &T {
        heap::alloc(count * sizeof T) as &T;
    };

    // http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/#mutator-allocator-collector
    fn heap::alloc(size: u32) -> &() {
        size = mem::align(size);

        let free_block = heap::find_free_block(size);
        if free_block as u32 != 0 {
            free_block->used = true;
            return free_block->data;
        };

        let total_size_to_alloc = size + sizeof heap::Block;

        let block = heap::TOTAL_ALLOCATED as &heap::Block;
        heap::TOTAL_ALLOCATED += total_size_to_alloc;

        // grow enough memory if we are out of space
        if heap::TOTAL_ALLOCATED >= __memory_size() * mem::PAGE_SIZE as i32 {
            let pages_to_grow = mem::align_to(total_size_to_alloc, mem::PAGE_SIZE);
            let grow_res = __memory_grow(pages_to_grow);
            if grow_res == (0 - 1) as i32 {
                panic("OOM");
            };
        };

        block->size = size;
        block->used = true;
        block->data = (block as u32 + sizeof heap::Block) as &();

        // init heap
        if heap::FIRST_BLOCK as u32 == 0 {
            heap::FIRST_BLOCK = block;
        };

        // chain block
        if heap::CURRENT_BLOCK as u32 != 0 {
            heap::CURRENT_BLOCK->next = block;
        };

        heap::CURRENT_BLOCK = block;

        return block->data;
    };

    fn heap::free(ptr: & ()) {
        let block = heap::get_block(ptr);
        block->used = false;
    };

    fn heap::get_block(ptr: &()) -> &heap::Block {
        return (ptr - sizeof heap::Block) as &heap::Block;
    };

    // first fit
    fn heap::find_free_block(size: u32) -> &heap::Block {
        let block = heap::FIRST_BLOCK;

        loop {
            if block as u32 == 0 || (!block->used && block->size >= size) {
                break;
            };

            block = block->next;
        };

        return block;
    };

// vec

    struct Vec {
        data: &(),
        size: u32,
        capacity: u32,
        item_size: u32,
        alloc_id: u32,
    };

    macro Vec::new!<T>() -> &Vec {
        Vec::new(sizeof T);
    };

    fn Vec::new(item_size: u32) -> &Vec {
        return Vec::with_capacity(10, item_size);
    };

    fn Vec::new_using(item_size: u32, alloc_id: u32) -> &Vec {
        return Vec::with_capacity_using(10, item_size, alloc_id);
    };

    macro Vec::with_capacity!<T>(capacity: u32) -> &Vec {
        Vec::with_capacity(capacity, sizeof T);
    };

    fn Vec::with_capacity(capacity: u32, item_size: u32) -> &Vec {
        return Vec::with_capacity_using(capacity, item_size, alloc::HEAP);
    };

    fn Vec::with_capacity_using(capacity: u32, item_size: u32, alloc_id: u32) -> &Vec {
        // TODO: look into `new` keyword
        let self_ptr = alloc!<Vec>(alloc_id);
        *self_ptr = Vec {
            data: alloc(alloc_id, capacity * item_size),
            size: 0,
            capacity: capacity,
            item_size: item_size,
            alloc_id: alloc_id,
        };
        return self_ptr;
    };

    fn Vec::free(&self) {
        free!<Vec>(self->alloc_id, self);
        free(self->alloc_id, self->data, self->capacity);
    };

    macro Vec::get!<T>(&self, index: u32) -> T {
        *(self.at(index) as &T);
    };

    macro Vec::set!<T>(&self, index: u32, item: T) {
        self.get!<T>(index) = item;
    };

    fn Vec::at(&self, index: u32) -> &() {
        Vec::_panic_if_out_of_bounds(self, index);

        return (self->data as u32 + index * self->item_size) as &();
    };

    fn Vec::at_unchecked(&self, index: u32) -> &() {
        return (self->data as u32 + index * self->item_size) as &();
    };

    fn Vec::swap(&self, index1: u32, index2: u32) {
        self._panic_if_out_of_bounds(index1);
        self._panic_if_out_of_bounds(index2);

        let item_size = self->item_size;
        mem::swap(
            (self->data as u32 + index1 * item_size) as &(),
            (self->data as u32 + index2 * item_size) as &(),
            item_size,
        );
    };

    macro Vec::push!<T>(&self, item: T) {
        *(self.push() as &T) = item;
    };

    fn Vec::push(&self) -> &() {
        self->size += 1;
        self._grow_if_needed();

        return self.at_unchecked(self->size - 1);
    };

    fn Vec::push_all(&self, items: &(), items_len: u32) {
        let old_len = self->size;
        self->size = old_len + items_len;

        self._grow_if_needed();

        mem::copy(
            items,
            (self->data as u32 + old_len * self->item_size) as &(),
            items_len * self->item_size,
        );
    };

    fn Vec::append(&self, other: &Vec) {
        self.push_all(other->data, other->size);
        other->size = 0;
    };

    fn Vec::pop_unchecked(&self) -> &() {
        self->size -= 1;
        return self.at_unchecked(self->size);
    };

    fn Vec::reverse(&self) {
        let start = 0;
        let end = self->size - 1;

        loop {
            if start >= end {
                break;
            };

            self.swap(start, end);
            start += 1;
            end -= 1;
        };
    };

    fn Vec::_grow_if_needed(&self) {
        if self->size != self->capacity {
            return;
        };

        if self->alloc_id == alloc::STACK {
            panic("Attempt to grow stack allocated vector");
        };

        let item_size = self->item_size;
        let old_capacity = self->capacity;
        let old_data = self->data;
        defer free(self->alloc_id, old_data, old_capacity * item_size);

        self->capacity = old_capacity * 2;
        self->data = alloc(self->alloc_id, self->capacity * item_size);

        mem::copy(old_data, self->data, self->size * item_size);
    };

    fn Vec::_panic_if_out_of_bounds(&self, index: u32) {
        if index < 0 || index >= self->size {
            panic("Vec access out of bounds");
        };
    };

// string

    type Vec::u8 = Vec;
    type String = Vec::u8;

    fn String::new(capacity: u32) -> &String {
        return Vec::with_capacity!<u8>(capacity);
    };

    fn String::new_using(capacity: u32, alloc_id: u32) -> &String {
        return Vec::with_capacity_using(capacity, sizeof u8, alloc_id);
    };

    fn String::clone(&self) -> &String {
        return String::from_str(str {
            data: self->data as &*u8,
            size: self->size,
        });
    };

    fn String::from_str(value: str) -> &String {
        let string = String::new(value.size);
        string.push_all(value.data as &(), value.size);
        return string;
    };

// str utils

    fn str::from_string(value: &String) -> str {
        return str { data: value->data as &u8, size: value->size };
    };

    fn str::char_at(self, index: u32) -> u8 {
        return *((self.data as u32 + index) as &u8);
    };

    fn str::clone(self) -> str {
        let cloned_data = alloc_many!<u8>(alloc::HEAP, self.size);
        mem::copy(self.data as &(), cloned_data as &(), self.size);
        return str {
            data: cloned_data,
            size: self.size,
        };
    };

    fn str::equals(self, other: str) -> bool {
        if self.size != other.size {
            return false;
        };

        let i = 0;
        loop {
            if i == self.size {
                break;
            };

            if *((self.data as u32 + i) as &u8) != *((other.data as u32 + i) as &u8) {
                return false;
            };

            i += 1;
        };

        return true;
    };

    fn str::skip_chars(self, char_count: u32) -> str {
        if self.size < char_count {
            return self;
        };

        return str {
            data: (self.data as u32 + char_count) as &*u8,
            size: self.size - char_count
        };
    };

// conversions

    fn u32::to_string(input: u32) -> &String {
        return u32::to_string_using(input, alloc::HEAP);
    };

    fn u32::to_string_using(input: u32, alloc_id: u32) -> &String {
        let output = String::new_using(32, alloc_id);

        if input == 0 {
            output.push!<u8>('0' as u8);
            return output;
        };

        loop {
            let rem = input % 10;

            output.push!<u8>(('0' + rem) as u8);
            input = input / 10;

            if input == 0 {
                break;
            };
        };

        output.reverse();

        return output;
    };

    fn u64::to_string(input: u64) -> &String {
        return u64::to_string_using(input, alloc::HEAP);
    };

    fn u64::to_string_using(input: u64, alloc_id: u32) -> &String {
        let output = String::new_using(32, alloc_id);

        if input == 0u64 {
            output.push!<u8>('0' as u8);
            return output;
        };

        loop {
            let rem = input % 10u64;

            output.push!<u8>(('0' + rem as u32) as u8);
            input = input / 10u64;

            if input == 0u64 {
                break;
            };
        };

        output.reverse();

        return output;
    };

    fn cstr_to_str(value: &*u8) -> str {
        let len = 0;

        loop {
            if *((value as u32 + len) as &u8) == 0 as u8 {
                break;
            };

            len += 1;
        };

        return str { data: value, size: len };
    };
