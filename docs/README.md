<h1>LO Docs</h1>

Documentation of LO language features.

> This is WIP and is updated in sync with [ParserV2](../src/parser_v2.rs). Main goal is to document **all** features for now, better structuring and wording will come later.

> For up-to-date code examples see [examples](../examples) directory.

<!-- TOC generated by `yzhang.markdown-all-in-one` VSCode extension -->

- [🪂 Top level expressions](#-top-level-expressions)
  - [Function definition](#function-definition)
- [🧑‍💻 Code Expressions](#-code-expressions)
  - [Integer literals](#integer-literals)
  - [Return](#return)
- [🧱 Types](#-types)
  - [Numerical types](#numerical-types)
- [💬 Comments](#-comments)
- [🔨 Compiler usage](#-compiler-usage)
  - [Compiling to WASM (main target)](#compiling-to-wasm-main-target)
  - [Inspecting code (IDE intergration)](#inspecting-code-ide-intergration)
  - [Pretty Printing](#pretty-printing)
    - [Comment rearrangement](#comment-rearrangement)
  - [Transpiling to C](#transpiling-to-c)
  - [Error format](#error-format)
- [🧪 Compiler development](#-compiler-development)
  - [Building the initial compiler](#building-the-initial-compiler)
  - [Running tests](#running-tests)

## 🪂 Top level expressions

Top level expressions are only allowed at the top level of the file (not inside functions).

### Function definition

```lo
fn answer(): u32 {
    return 42;
};
```

> Expression type: `never`

Can be exported from WASM module like this:

```
export fn main(): u32 {
    return 0;
}
```

> Function is exported with the original name

## 🧑‍💻 Code Expressions

Code expressions are allowed inside function bodies.

### Integer literals

```
123 // i32 literal
```

Int literals are always fully typed, there is no generic "number" type that will get narrowed later.

> Expression type: depends on the literal

### Return

```
return <value>;
```

> Expression type: `never`

## 🧱 Types

Types lol.

### Numerical types

- `u32`
    > transpiles to C's `unsigned int`

## 💬 Comments

Only `//` comments are supported for now.

```
// this is a comment
fn main(): u32 {
    // this is another comment
    return 0;
};
```

Comments are allowed between any tokens, but they might get moved during formatting. See [Pretty Printing](#pretty-printing) for more info.

## 🔨 Compiler usage

Compiler is shipped as a standalone WASM binary: `lo.wasm`

It uses [WASI](https://wasi.dev/) preview 1 APIs for communication. This allows it to be executed in any WASI compatible runtime.

Example of running the compiler using [wasmtime](https://wasmtime.dev/):

```bash
wasmtime --dir=. lo.wasm
```

This should print the following:

```
Usage: lo <file> [mode]
  where [mode] is either:
    --inspect
    --pretty-print
    --print-c
  No [mode] means compilation to wasm
```

---

> NOTE: following examples will be using `lo` "executable". This is OS dependant and is not shipped with the compiler.
>
> In Linux/MacOS you can alias it to `wasmtime --dir=. lo.wasm $@`

### Compiling to WASM (main target)

```
lo input.lo
```

> Compiles `input.lo` file into a wasm module
>
> `<stdout>` - WASM module in binary format <br>
> `<stderr>` - Any compilation errors. See [error format](#error-format)

> NOTE: any imported files will be automatically resolved. You don't need to provide them separately.

### Inspecting code (IDE intergration)

```bash
lo input.lo --inspect
```

> Prints inspection info of `input.lo` file in JSON format. Useful for IDE integrations.
>
> `<stdout>` - JSON object with inspection results <br>
> `<stderr>` - Any compilation errors. See [error format](#error-format)

Inspection object schema is defined as `DiagnisticItem` in [VSCode extension sources](../vscode-ext/src/extension.ts)

### Pretty Printing

> NOTE: this feature is WIP and does not support the full syntax yet <br>
> NOTE: this currently does not resolve imports, processes only the single file

Usage:

```bash
lo input.lo --pretty-print
```

> Formats `input.lo` using non-configurable formatting style
>
> `<stdout>` - Formatted source <br>
> `<stderr>` - Any compilation errors. See [error format](#error-format)

#### Comment rearrangement

Comments that are placed in "weird" places will be moved into closest "proper" places.

This keeps formatter quite simple and makes comment placing more consistent.

For example the following:

```lo
// this is a comment
fn main():
// this will be moved
u32 { // this will also be moved
    // this is fine
    return 0; // this will also be moved
};
```

Will get formatted as:

```lo
// this is a comment
fn main(): u32 {
    // this will be moved
    // this will also be moved
    // this is fine
    return 0;
    // this will also be moved
};
```

### Transpiling to C

> NOTE: this feature is WIP and does not support the full syntax yet <br>
> NOTE: this currently does not resolve imports, processes only the single file <br>
> NOTE: This feature will probably not get tested much as the main target is WASM

```bash
lo <input.lo> --print-c
```

> Transpiles the input file into "equivalent" C source code.
>
> `<stdout>` - C source code <br>
> `<stderr>` - Any compilation errors. See [error format](#error-format)

### Error format

Errors are printed to `<stderr>` in the following format:
```
<file-path>:<line>:<col> - <message>
```

This makes errors clickable in VSCode's terminal (and probably others).

> NOTE: Currently only a single error can be emitted.


## 🧪 Compiler development

### Building the initial compiler

- Requirements:
  - Install [rustup](https://www.rust-lang.org/tools/install)
  - Install nightly: `rustup toolchain install nightly`
  - Add WASM target: `rustup +nightly target add wasm32-unknown-unknown`
  - You can also find configs for GitHub Codespaces and GitPod in this repo
- Run `./build.sh`

  > This will build the compiler with cargo, putting resulting WASM binary into `lo.wasm`

### Running tests

- Requirements:
  - Install [Node.js](https://nodejs.org/en/download/package-manager) for running tests
- Run `./utils.mjs test`

  > This runs tests defined in `utils.mjs`. Test programs are located in `examples/test`

> NOTE: there is currently no built-in testing solution in the compiler, existing test setup is good enough for now.
