;; <wasi>
    (global FD_STDIN u32 0)
    (global FD_STDOUT u32 1)

    (struct &IOVec* (actual ptr))
    (struct IOVec (base ptr) (len u32))

    (import fn fd_read [
        (file_descriptor u32) ;; file_descriptor
        (&iovs           &IOVec*) ;; The pointer to the iov array
        (iovs_len        u32) ;; Amount of IOVec
        (&nread          u32) ;; Pointer to store the number of bytes read
    ] [i32] :from wasi_snapshot_preview1 fd_read)

    (import fn fd_write [
        (file_descriptor u32) ;; file_descriptor
        (&iovs           &IOVec*) ;; The pointer to the iov array
        (iovs_len        u32) ;; Amount of IOVec
        (&nwritten       u32) ;; Pointer to store the number of bytes written
    ] [i32] :from wasi_snapshot_preview1 fd_write)
;; </wasi>

;; <mem>
    (global mut Mem/HEAP_INDEX u32 4) ;; 0-4 is for Wasi/fd_write nwritten 
    (fn Mem/alloc [(size u32)][ptr]({ref : ptr}{ref = Mem/HEAP_INDEX}{Mem/HEAP_INDEX = {Mem/HEAP_INDEX + size}} ref))
    (fn Mem/free [(ref ptr)][]())
    (fn Mem/copy [(src ptr)(dist ptr)(size u32)][]((loop ((if {size == 0}(break)){size = {size - 1}}(store i32/u8 {dist + size}(load i32/u8 {src + size}))))))
    (fn Mem/swap [(ref1 ptr)(ref2 ptr)(size u32)][]((loop ((if {size == 0}(break)){size = {size - 1}}{tmp : u8}{tmp = (load i32/u8 {ref1 + size})}(store i32/u8 {ref1 + size}(load i32/u8 {ref2 + size}))(store i32/u8 {ref2 + size} tmp)))))
;; </mem>

(mem m1 :min 1000)
(export mem m1 :as memory)

(struct &u8* (actual ptr))
(struct &u32 (actual ptr))

(export main :as _start)
(fn main [] [i32] (
    (fd_pipe FD_STDIN FD_STDOUT 256)
))

(fn fd_pipe [(fd_in i32) (fd_out i32) (chunk_size u32)] [i32] (
    {&chunk : &u8*}
    {&chunk = (Mem/alloc chunk_size)}

    {&iov : &IOVec*}
    {&iov = (Mem/alloc (sizeof IOVec))}
    (store i32 &iov &chunk)

    {&nread : &u32}
    {&nread = (Mem/alloc (sizeof u32))}

    {result : i32}
    {result = 0}

    {io_res : i32}

    (loop (
        (store i32 {&iov + (sizeof u32)} chunk_size)
        {io_res = (fd_read fd_in &iov 1 &nread)}
        (if {io_res != 0} (do
            {result = 1}
            (break)
        ))
        
        {nread : u32}
        {nread = (load i32 &nread)}

        (if {nread == 0} (break))

        (store i32 {&iov + (sizeof u32)} nread)
        {io_res = (fd_write fd_out &iov 1 &nread)}
        (if {io_res != 0} (do
            {result = 1}
            (break)
        ))
    ))

    (Mem/free &chunk)
    (Mem/free &iov)
    (Mem/free &nread)

    (return result)
))
