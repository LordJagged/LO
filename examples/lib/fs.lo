include "./std.lo";
include "./wasi.lo";
include "./print.lo";

struct fs {};

// fs expects host to preopen "." on fd 3
const fs::CWD_PREOPEN_FD = 3;

// TODO: return errors instead of exiting with logs
fn fs::read_file(file_name: str): &String {
    fs::_unlock();

    let fd = fs::open(file_name) catch _ {
        fputs(wasi::FD_STDERR, "Error opening file: ");
        fputs(wasi::FD_STDERR, file_name);
        fputs(wasi::FD_STDERR, "\n");
        wasi::proc_exit(1);
    };
    defer let _ = wasi::fd_close(fd);

    return fs::read_fd(fd);
};

let fs::unlocked = false;

// https://github.com/microsoft/vscode-wasm/issues/161
fn fs::_unlock() {
    if fs::unlocked {
        return;
    };

    let err = 0;
    defer if err != 0 {
        fputs(wasi::FD_STDERR, "Error unlocking fs (code=");
        fprint_u32(wasi::FD_STDERR, err);
        fputs(wasi::FD_STDERR, ")\n");
        wasi::proc_exit(1);
    };

    let prestat = tmp_alloc!<wasi::prestat>();
    err = wasi::fd_prestat_get(fs::CWD_PREOPEN_FD, prestat);
    if err != 0 { return; };

    let dir_path = tmp_alloc_many!<u8>(prestat.pr_name_len);
    err = wasi::fd_prestat_dir_name(fs::CWD_PREOPEN_FD, dir_path, prestat.pr_name_len);
    if err != 0 { return; };

    let fdstat = tmp_alloc!<wasi::fdstat>();
    err = wasi::fd_fdstat_get(fs::CWD_PREOPEN_FD, fdstat);
    if err != 0 { return; };

    let prestat2 = tmp_alloc!<wasi::prestat>();
    let _ = wasi::fd_prestat_get(fs::CWD_PREOPEN_FD + 1, prestat2);

    fs::unlocked = true;
};

struct fs::FdOpenRes {
    err: wasi::Err,
    fd: u32,
};

fn fs::open(file_path: str): u32 throws wasi::Err {
    let fd_ref = tmp_alloc!<u32>();

    let err = wasi::path_open(
        fs::CWD_PREOPEN_FD,
        1, file_path.data, file_path.size, 0, 264240830u64, 268435455u64, 0,
        fd_ref,
    );

    if err != 0 {
        throw err;
    };

    return *fd_ref;
};

fn fs::read_fd(fd: u32): &String {
    let output = Vec::with_capacity!<u8>(256);

    let chunk = tmp_alloc_many!<u8>(256);

    let in_vec = tmp_alloc!<wasi::IOVec>();
    *in_vec = wasi::IOVec { base: chunk, size: 256 };

    let nread_ref = tmp_alloc!<u32>();

    loop {
        let _err = wasi::fd_read(fd, in_vec, 1, nread_ref);

        let nread = *nread_ref;
        if nread == 0 {
            break;
        };

        output.push_all(chunk as &void, nread);
    };

    return output;
};


fn fs::pipe(fd_in: u32, fd_out: u32, chunk_size: u32): bool {
    let chunk = tmp_alloc_many!<u8>(chunk_size);

    let iov = tmp_alloc!<wasi::IOVec>();
    *iov = wasi::IOVec { base: chunk, size: 0 };

    let nread_ref = tmp_alloc!<u32>();

    loop {
        iov.size = chunk_size;
        let io_res = wasi::fd_read(fd_in, iov, 1, nread_ref);
        if io_res != 0 {
            return false;
        };

        let nread = *nread_ref;
        if nread == 0 {
            break;
        };

        iov.size = nread;
        io_res = wasi::fd_write(fd_out, iov, 1, nread_ref);
        if io_res != 0 {
            return false;
        };
    };

    return true;
};

fn fs::close(fd: u32) {
    let _ = wasi::fd_close(fd); // TODO: ignore close error?
};
