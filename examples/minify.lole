(mod lib/std)
(mod lib/wasi)
(mod lib/print)
(mod lib/args)

(mem m1 :min 1000)
(export mem m1 :as memory)

;; #region Imports

;; Parser
(global Parser/SExpr/Atom u8 0)
(global Parser/SExpr/List u8 1)
(struct Parser/SExpr (kind u8)(data ptr))
(global Parser/ParseError/UnexpectedEOF u32 0)
(global Parser/ParseError/UnexpectedChar u32 1)
(struct Parser/ParseResult (ok bool)(index u32)(data u32))
(global CHAR_TAB u8 009)(global CHAR_NEWLINE u8 010)(global CHAR_SPACE u8 032)(global CHAR_SEMICOLON u8 059)(global CHAR_LPAREN u8 040)(global CHAR_RPAREN u8 041)(global CHAR_LCURLY u8 123)(global CHAR_RCURLY u8 125)(global CHAR_LBRACK u8 091)(global CHAR_RBRACK u8 093)
(fn Parser/parse [(chars StringSlice)][Parser/ParseResult]({index : u32}{index = 0}{index = (Parser/skip_space chars index)}{&items : &Vec}{&items = (Vec/new 6 (sizeof Parser/SExpr))}(loop ((if {index >= {chars . size}}(break)){char_res : Parser/CharAtResult}{char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedEOF)))(if (not (Parser/is_list_start {char_res . char}))(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedChar))){res : Parser/ParseResult}{res = (Parser/parse_list chars index)}(if (not {res . ok})(return res))(Vec/push_all &items {res . data} 1){index = (Parser/skip_space chars {res . index})}))(struct.new Parser/ParseResult true index &items)))
(fn Parser/parse_expr [(chars StringSlice)(index u32)][Parser/ParseResult]({char_res : Parser/CharAtResult}{char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedEOF)))(if (Parser/is_list_start {char_res . char})(return (Parser/parse_list chars index)))(Parser/parse_atom chars index)))
(fn Parser/parse_atom [(chars StringSlice)(index u32)][Parser/ParseResult]({atom_len : u32}{atom_len = 0}(loop ({char_res : Parser/CharAtResult}{char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(break))(if (|| (|| (Parser/is_space {char_res . char})(Parser/is_list_end {char_res . char})){{char_res . char} == CHAR_SEMICOLON})(break)){index = {index + 1}}{atom_len = {atom_len + 1}})){&atom : &Vec}{&atom = (Vec/new atom_len 1)}(Vec/push_all &atom {{{chars . data} + index} - atom_len} atom_len){&expr : ptr}{&expr = (Mem/alloc (sizeof Parser/SExpr))}(store Parser/SExpr &expr (struct.new Parser/SExpr Parser/SExpr/Atom &atom))(struct.new Parser/ParseResult true index &expr)))
(fn Parser/parse_list [(chars StringSlice)(index u32)][Parser/ParseResult]({char_res : Parser/CharAtResult}{char_res = (Parser/char_at chars index)}{list_start_char : u8}{list_start_char = {char_res . char}}{index = {index + 1}}{index = (Parser/skip_space chars index)}{&items : &Vec}{&items = (Vec/new 6 (sizeof Parser/SExpr))}(loop ({char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedEOF)))(if (Parser/is_list_end {char_res . char})(break)){res : Parser/ParseResult}{res = (Parser/parse_expr chars index)}(if (not {res . ok})(return res))(Vec/push_all &items {res . data} 1){index = (Parser/skip_space chars {res . index})})){char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedEOF))){list_end_char : u8}{list_end_char = {char_res . char}}{index = {index + 1}}(if (not (Parser/is_valid_list_chars list_start_char list_end_char))(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedEOF)))(if {{list_start_char == CHAR_LCURLY} && {(Vec/len &items) >= 2}}(Vec/swap &items 0 1)){&expr : ptr}{&expr = (Mem/alloc (sizeof Parser/SExpr))}(store Parser/SExpr &expr (struct.new Parser/SExpr Parser/SExpr/List &items))(struct.new Parser/ParseResult true index &expr)))
(fn Parser/skip_space [(chars StringSlice)(index u32)][u32]({char_res : Parser/CharAtResult}(loop ({char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(break))(if (not (Parser/is_space {char_res . char}))(break)){index = {index + 1}}))(if {{char_res . ok} && {{char_res . char} == CHAR_SEMICOLON}}(do {index = {index + 1}}(loop ({char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(break))(if {{char_res . char} == CHAR_NEWLINE}(break)){index = {index + 1}}))(if {{char_res . ok} && {{char_res . char} == CHAR_SEMICOLON}}{index = {index + 1}})(return (Parser/skip_space chars index)))) index))
(fn Parser/is_list_start [(char u8)][bool]((|| (|| {char == CHAR_LPAREN}{char == CHAR_LCURLY}){char == CHAR_LBRACK})))
(fn Parser/is_list_end [(char u8)][bool]((|| (|| {char == CHAR_RPAREN}{char == CHAR_RCURLY}){char == CHAR_RBRACK})))
(fn Parser/is_valid_list_chars [(start u8)(end u8)][bool]((|| (|| {{start == CHAR_LPAREN} && {end == CHAR_RPAREN}}{{start == CHAR_LCURLY} && {end == CHAR_RCURLY}}){{start == CHAR_LBRACK} && {end == CHAR_RBRACK}})))
(fn Parser/is_space [(char u8)][bool]((|| (|| {char == CHAR_SPACE}{char == CHAR_NEWLINE}){char == CHAR_TAB})))
(struct Parser/CharAtResult (ok bool)(char u8))
(fn Parser/char_at [(chars StringSlice)(index u32)][Parser/CharAtResult]((if {index >= {chars . size}}(return (struct.new Parser/CharAtResult false 0)))(struct.new Parser/CharAtResult true (StringSlice/Parser/char_at chars index))))
(fn Parser/index_to_position [(chars StringSlice)(index u32)][ u32 u32]({line : u32}{col : u32}{(line col) = (pack 1 1)}{char_index : u32}{char_index = 0}(loop ((if {char_index >= {chars . size}}(break))(if {char_index >= index}(break)){char : u32}{char = (StringSlice/Parser/char_at chars char_index)}(if {char == CHAR_NEWLINE}(do {col = 1}{line = {line + 1}}{char_index = {char_index + 1}}(continue))){col = {col + 1}}{char_index = {char_index + 1}}))(pack line col))) 

;; #endregion

(struct MinifyResult (ok bool) (data ptr))

(struct &Vec<Parser/SExpr> (actual ptr))
(struct &Vec<u8> (actual ptr))

(export main :as _start)
(fn main [(chars StringSlice)] [i32] (
    {parse_res : Parser/ParseResult}
    {parse_res = (Parser/parse chars)}

    (if (not {parse_res . ok}) (do
        (return 1)
    ))

    {&exprs : &Vec<Parser/SExpr>}
    {&exprs = {parse_res . data}}
    {i : u32}
    {i = 0}
    ;; TODO: implement dump
    ;; {&output : &Vec<u8>}
    ;; {&output = (Vec/new 256 1)}

    (loop (
        (if {i == (Vec/len &exprs)}
            (break)
        )

        ;; TODO: implement dump
        ;; {expr : Parser/SExpr}
        ;; {expr = (load Parser/SExpr {&exprs + {i * (sizeof Parser/SExpr)}})}
        ;; (dump_expr expr &output)

        {i = {i + 1}}
    ))

    {&str : &Vec<u8>}
    {&str = (u32_to_string i)}
    (Vec/push_u8 &str CHAR_NEWLINE)
    
    {str : Vec}
    {str = (load Vec &str)}

    (print_str_slice {str . data_ref} {str . length})

    (return 0)
))

;; ascii digits: 48-57
(fn u32_to_string [(input u32)] [&Vec<u8>] (
    {&output : &Vec<u8>}
    {&output = (Vec/new 32 1)}

    (if {input == 0} (do
        (Vec/push_u8 &output 48)
        (return &output)
    ))

    (loop (
        {rem : u32}
        {rem = {input % 10}}
      
        (Vec/push_u8 &output {48 + rem})
        {input = {input / 10}}
        
        (if {input == 0} (break))
    ))
    
    (Vec/reverse &output)

    (return &output)
))

(fn Vec/reverse [(&self &Vec)] [] (
    {start : u32}
    {start = 0}
    {end : u32}
    {end = {(Vec/len &self) - 1}}
    
    (loop (
        (if {start >= end} (break))

        (Vec/swap &self start end)
        {start = {start + 1}}
        {end = {end - 1}}
    ))
))

;; TODO: implement dump
;; (fn dump_expr [(expr Parser/SExpr) (&output &Vec)] [] (
    
;; ))
