(mod lib/std)
(mod lib/lo/ast)

(struct Lo/Parser
    (file_name StringSlice)
    (chars StringSlice)
    (index u32)
    (line u32)
    (col u32)
)

(struct Lo/Parser/ParseResult
    (ok bool)
    (data (& void)) ; (& Lo/Ast/SExpr) | (& Lo/Ast/CompileError)
)

(struct Lo/Parser/ParseScriptResult
    (ok bool)
    (data (& void)) ; (& Vec<Lo/Ast/SExpr>) | (& Lo/Ast/CompileError)
)

; public interface
(fn Lo/Parser/parse [(file_name StringSlice) (script StringSlice)] Lo/Parser/ParseScriptResult (
    {parser := (new Lo/Parser (Lo/Parser/new file_name script)
        :using Alloc/STACK)}
    (defer (free Alloc/STACK parser (sizeof Lo/Parser)))

    (return (Lo/Parser/parse_all parser))
))

(fn Lo/Parser/new [(file_name StringSlice) (script StringSlice)] Lo/Parser (
    (return (Lo/Parser
        :file_name file_name
        :chars script
        :index 0
        :line 1
        :col 1
    ))
))

(fn Lo/Parser/parse_all [(self (& Lo/Parser))] Lo/Parser/ParseScriptResult (
    (Lo/Parser/skip_space self)

    {items := (Vec/new 10 (sizeof Lo/Ast/SExpr))}

    (loop (
        ; TODO: support chaining `->`
        (if {self -> index >= {self -> chars . size}} (
            (break)
        ))

        {res := (Lo/Parser/current_char self)}
        (if (not {res . ok}) (
            (return {res as Lo/Parser/ParseScriptResult})
        ))

        (if (not (Lo/Parser/is_list_start {res . data})) (
            (return (Lo/Parser/ParseScriptResult
                :ok false
                :data {(Lo/Parser/err_unexpected_char self) as (& void)}
            ))
        ))

        {expr_res := (Lo/Parser/parse_list self)}
        (if (not {expr_res . ok}) (
            (return {expr_res as Lo/Parser/ParseScriptResult})
        ))

        (Lo/Parser/skip_space self)

        (Vec/push_all items {expr_res . data} 1)
    ))

    (return (Lo/Parser/ParseScriptResult
        :ok true
        :data {items as (& void)}
    ))
))

(fn Lo/Parser/parse_expr [(self (& Lo/Parser))] Lo/Parser/ParseResult (
    {res := (Lo/Parser/current_char self)}
    (if (not {res . ok}) (
        (return {res as Lo/Parser/ParseResult})
    ))

    (if (Lo/Parser/is_list_start {res . data}) (
        (return (Lo/Parser/parse_list self))
    ))

    (return (Lo/Parser/parse_atom self))
))

(fn Lo/Parser/parse_atom [(self (& Lo/Parser))] Lo/Parser/ParseResult (
    {res := (Lo/Parser/current_char self)}
    (if (not {res . ok}) (
        (return {res as Lo/Parser/ParseResult})
    ))

    (if {res . data == (char_code "\"")} (
        (return (Lo/Parser/parse_string self))
    ))

    (return (Lo/Parser/parse_symbol self))
))

(fn Lo/Parser/parse_string [(self (& Lo/Parser))] Lo/Parser/ParseResult (
    {loc := (Lo/Parser/loc self)}

    (Lo/Parser/next_char self) ; skip start quote

    {value := (String/new 6)}

    (loop (
        {res := (Lo/Parser/current_char self)}
        (if (not {res . ok}) (
            (return {res as Lo/Parser/ParseResult})
        ))

        (if {res . data == (char_code "\"")} (
            (break)
        ))

        (if {res . data != (char_code "\\")} (
            {u8 @ (Vec/push value) = {res . data as u8}}
            (Lo/Parser/next_char self)
            (continue)
        ))
        (Lo/Parser/next_char self) ; skip '\'

        {res = (Lo/Parser/current_char self)}
        (if (not {res . ok}) (
            (return {res as Lo/Parser/ParseResult})
        ))

        (if {res . data == (char_code "n")} (
            {u8 @ (Vec/push value) = {(char_code "\n") as u8}}
            (Lo/Parser/next_char self)
            (continue)
        ))

        (if {res . data == (char_code "t")} (
            {u8 @ (Vec/push value) = {(char_code "\t") as u8}}
            (Lo/Parser/next_char self)
            (continue)
        ))

        (if {res . data == (char_code "\\")
                || {res . data == (char_code "\"")}} (
            {u8 @ (Vec/push value) = {res . data as u8}}
            (Lo/Parser/next_char self)
            (continue)
        ))

        (return (Lo/Parser/ParseResult
            :ok false
            :data {(Lo/Parser/err_unexpected_char self) as (& void)}
        ))
    ))

    (Lo/Parser/next_char self) ; skip end quote

    {loc . item_size = {self -> index - {loc . offset}}}

    (return (Lo/Parser/ParseResult
        :ok true
        :data {(new Lo/Ast/SExpr (Lo/Ast/SExpr
            :kind Lo/Ast/SExpr/ATOM
            :value {(new Lo/Ast/SExpr/Atom (Lo/Ast/SExpr/Atom
                :value value
                :kind Lo/Ast/AtomKind/STRING
                :loc loc
            )) as (& void)}
        )) as (& void)}
    ))
))

(fn Lo/Parser/parse_symbol [(self (& Lo/Parser))] Lo/Parser/ParseResult (
    {loc := (Lo/Parser/loc self)}

    (loop (
        {res := (Lo/Parser/current_char self)}
        (if {(Lo/Parser/is_space {res . data})
                || (Lo/Parser/is_list_end {res . data})
                || {res . data == (char_code ";")}} (
            (break)
        ))
        (Lo/Parser/next_char self)
    ))

    {loc . item_size = {self -> index - {loc . offset}}}

    {value := (String/from_slice
        {self -> chars . data + {loc . offset}} {loc . item_size}) }

    (return (Lo/Parser/ParseResult
        :ok true
        :data {(new Lo/Ast/SExpr (Lo/Ast/SExpr
            :kind Lo/Ast/SExpr/ATOM
            :value {(new Lo/Ast/SExpr/Atom (Lo/Ast/SExpr/Atom
                :value value
                :kind Lo/Ast/AtomKind/SYMBOL
                :loc loc
            )) as (& void)}
        )) as (& void)}
    ))
))

(fn Lo/Parser/parse_list [(self (& Lo/Parser))] Lo/Parser/ParseResult (
    {loc := (Lo/Parser/loc self)}

    {res := (Lo/Parser/current_char self)}
    (if (not {res . ok}) (
        (return {res as Lo/Parser/ParseResult})
    ))
    {list_start_char := {res . data}}
    (Lo/Parser/next_char self) ; eat list start

    (Lo/Parser/skip_space self)

    {items := (Vec/new 6 (sizeof Lo/Ast/SExpr))}

    (loop (
        {res = (Lo/Parser/current_char self)}
        (if (not {res . ok}) (
            (return {res as Lo/Parser/ParseResult})
        ))

        (if (Lo/Parser/is_list_end {res . data}) (
            (break)
        ))

        {expr_res := (Lo/Parser/parse_expr self)}
        (if (not {expr_res . ok}) (
            (return expr_res)
        ))
        (Vec/push_all items {expr_res . data} 1)

        (Lo/Parser/skip_space self)
    ))

    {res = (Lo/Parser/current_char self)}
    (if (not {res . ok}) (
        (return {res as Lo/Parser/ParseResult})
    ))
    {list_end_char := {res . data}}
    (Lo/Parser/next_char self) ; eat list end

    {loc . item_size = {self -> index - {loc . offset}}}

    (if {list_start_char == (char_code "{") && {items -> size >= 2}} (
        (return (Lo/Parser/m_expr_to_s_expr_and_validate items loc))
    ))

    (return (Lo/Parser/ParseResult
        :ok true
        :data {(new Lo/Ast/SExpr (Lo/Ast/SExpr
            :kind Lo/Ast/SExpr/LIST
            :value {(new Lo/Ast/SExpr/List (Lo/Ast/SExpr/List
                :value items
                :loc loc
            )) as (& void)}
        )) as (& void)}
    ))
))

(fn Lo/Parser/skip_space [(self (& Lo/Parser))] void (
    {res : Lo/Parser/CharAtResult}

    (loop (
        {res = (Lo/Parser/current_char self)}
        (if (not {res . ok}) (
            (return)
        ))
        (if (not (Lo/Parser/is_space {res . data})) (
            (break)
        ))

        (Lo/Parser/next_char self)
    ))

    (if {res . data != (char_code ";")} (
        (return)
    ))
    (Lo/Parser/next_char self)

    (loop (
        {res = (Lo/Parser/current_char self)}
        (if (not {res . ok}) (
            (return)
        ))
        (if {res . data == (char_code "\n")} (
            (break)
        ))
        (Lo/Parser/next_char self)
    ))

    (if {res . data == (char_code ";")} (
        (Lo/Parser/next_char self)
    ))

    (Lo/Parser/skip_space self)
))

(fn Lo/Parser/next_char [(self (& Lo/Parser))] void (
    {self -> index += 1}

    {res := (Lo/Parser/current_char self)}
    (if (not {res . ok}) (
        (return)
    ))

    (if {res . data == (char_code "\n")} (
        {self -> col = 0}
        {self -> line += 1}
        (return)
    ))

    {self -> col += 1}
))

(struct Lo/Parser/CharAtResult
    (ok bool)
    (data (& void)) ; u8 | (& CompileError)
)

(fn Lo/Parser/current_char [(self (& Lo/Parser))] Lo/Parser/CharAtResult (
    {chars := {self -> chars}}

    (if {self -> index >= {chars . size}} (
        (return (Lo/Parser/CharAtResult
            :ok false
            :data {(Lo/Parser/err_unexpected_eof self) as (& void)}
        ))
    ))

    (return (Lo/Parser/CharAtResult
        :ok true
        :data {(StringSlice/char_at chars {self -> index}) as (& void)}
    ))
))

(fn Lo/Parser/err_unexpected_char [(self (& Lo/Parser))] (& Lo/Ast/CompileError) (
    (return (new Lo/Ast/CompileError (Lo/Ast/CompileError
        :message (String/from_slice "ParseError: Unexpected character")
        :loc (Lo/Parser/loc self)
    )))
))

(fn Lo/Parser/err_unexpected_eof [(self (& Lo/Parser))] (& Lo/Ast/CompileError) (
    (return (new Lo/Ast/CompileError (Lo/Ast/CompileError
        :message (String/from_slice "ParseError: Unexpected EOF")
        :loc (Lo/Parser/loc self)
    )))
))

(fn Lo/Parser/loc [(self (& Lo/Parser))] Lo/Ast/Location (
    (return (Lo/Ast/Location
        :file_name (StringSlice/clone {self -> file_name})
        :offset {self -> index}
        :item_size 1
        :line {self -> line}
        :col {self -> col}
    ))
))

(fn Lo/Parser/m_expr_to_s_expr_and_validate [(items (& Vec<Lo/Ast/SExpr>)) (loc Lo/Ast/Location)] Lo/Parser/ParseResult (
    (if {items -> size % 2 != 1} (
        (return (Lo/Parser/ParseResult
            :ok false
            :data {(new Lo/Ast/CompileError (Lo/Ast/CompileError
                :message (String/from_slice "ParseError: Invalid m-expr: even item_size")
                :loc loc
            )) as (& void)}
        ))
    ))

    (if {items -> size < 2} (
        (return (Lo/Parser/ParseResult
            :ok true
            :data {(new Lo/Ast/SExpr (Lo/Ast/SExpr
                :kind Lo/Ast/SExpr/LIST
                :value {(new Lo/Ast/SExpr/List (Lo/Ast/SExpr/List
                    :value items
                    :loc loc
                )) as (& void)}
            )) as (& void)}
        ))
    ))

    (return (Lo/Parser/ParseResult
        :ok true
        :data {(new Lo/Ast/SExpr
            (Lo/Parser/m_expr_to_s_expr items loc)
        ) as (& void)}
    ))
))

; ❓ {1 + 2 - 3 * 4}
; 🚫 (+ 1 (- 2 (* 3 4)))
; ✅ (* (- (+ 1 2) 3) 4)
(fn Lo/Parser/m_expr_to_s_expr [(items (& Vec<Lo/Ast/SExpr>)) (loc Lo/Ast/Location)] Lo/Ast/SExpr (
    (if {items -> size == 1} (
        (defer (Vec/free items))
        (return {Lo/Ast/SExpr @ (Vec/at items 0)})
    ))

    {rhs := {Lo/Ast/SExpr @ (Vec/pop_unchecked items)}}
    {op := {Lo/Ast/SExpr @ (Vec/pop_unchecked items)}}
    {lhs := (Lo/Parser/m_expr_to_s_expr items (Lo/Ast/Location/clone loc))}

    {sexpr_items := (Vec/new 3 (sizeof Lo/Ast/SExpr))}
    {Lo/Ast/SExpr @ (Vec/push sexpr_items) = op}
    {Lo/Ast/SExpr @ (Vec/push sexpr_items) = lhs}
    {Lo/Ast/SExpr @ (Vec/push sexpr_items) = rhs}

    (return (Lo/Ast/SExpr
        :kind Lo/Ast/SExpr/LIST
        :value {(new Lo/Ast/SExpr/List (Lo/Ast/SExpr/List
            :value sexpr_items
            :loc loc
        )) as (& void)}
    ))
))

(fn Lo/Parser/is_list_start [(char u8)] bool (
    (return {
        {char == (char_code "(")} ||
        {char == (char_code "{")} ||
        {char == (char_code "[")}
    })
))

(fn Lo/Parser/is_list_end [(char u8)] bool (
    (return {
        {char == (char_code ")")} ||
        {char == (char_code "}")} ||
        {char == (char_code "]")}
    })
))

(fn Lo/Parser/is_valid_list_chars [(start u8) (end u8)] bool (
    (return {
        {start == (char_code "(") && {end == (char_code ")")}} ||
        {start == (char_code "{") && {end == (char_code "}")}} ||
        {start == (char_code "[") && {end == (char_code "]")}}
    })
))

(fn Lo/Parser/is_space [(char u8)] bool (
    (return {
        {char == (char_code " ")} ||
        {char == (char_code "\n")} ||
        {char == (char_code "\t")}
    })
))
