(mod lib/std)
(mod lib/lole/ir)
(mod lib/lole/parser)

(struct Lole/Compiler/CompileResult
    (ok bool)
    (data ptr) ; 0 | (& Lole/Ast/CompileError)
)

(fn Lole/Compiler/compile [
    (&exprs (& Vec<Lole/Ast/SExpr>)) (&wasm_module (& Lole/Wasm/WasmModule))
] [Lole/Compiler/CompileResult] (
    {&ctx : (& Lole/Ir/ModuleContext) = (Lole/Ir/ModuleContext/new &wasm_module)}
    (defer (Lole/Ir/ModuleContext/free &ctx))

    {i : u32 = 0}
    (loop (
        (if {i == (Vec/len &exprs)} (break))

        {res : Lole/Compiler/CompileResult =
            (Lole/Compiler/compile_top_level_expr
                {Lole/Ast/SExpr @ (Vec/at &exprs i)}
                &ctx
            )
        }
        (if (not {res . ok}) (return res))

        {i += 1}
    ))

    {&fn_defs : (& Dict<Lole/Ir/FnDef>) = {Lole/Ir/ModuleContext @ &ctx . &fn_defs}}
    {&fn_exports : (& Vec<String>) = {Lole/Ir/ModuleContext @ &ctx . &fn_exports}}

    ; push function exports
    {i = 0}
    (loop (
        (if {i == (Vec/len &fn_exports)} (break))

        {fn_export : Lole/Ir/FnExport = {Lole/Ir/FnExport @ (Vec/at &fn_exports i)}}

        {fn_def_res : Dict/GetResult = (Dict/get &fn_defs {fn_export . &in_name})}
        (if (not {fn_def_res . ok}) (do
            {&msg : (& String) = (String/from_slice "Cannot export unknown function: ")}
            (Vec/push_all &msg (Vec/as_slice {fn_export . &in_name}))

            (return false (new Lole/Ast/CompileError (do
                &msg
                (Lole/Ast/Location/clone {fn_export . loc})
            )))
        ))
        {fn_def : Lole/Ir/FnDef = {Lole/Ir/FnDef @ {fn_def_res . &value}}}

        {&exports : (& Vec) = {Lole/Wasm/WasmModule @ &wasm_module . &exports}}

        {Lole/Wasm/WasmExport @ (Vec/push_undef &exports) = (struct.new Lole/Wasm/WasmExport
            Lole/Wasm/WasmExportType/FUNC
            (String/clone {fn_export . &out_name})
            {Lole/Ir/ModuleContext @ &ctx . imported_fns_count + {fn_def . fn_index}}
        )}

        {i += 1}
    ))

    {&fn_bodies : (& Dict<Lole/Ir/FnDef>) = {Lole/Ir/ModuleContext @ &ctx . &fn_bodies}}
    {&fn_types : (& Vec<Lole/Wasm/WasmFnType>) = {Lole/Wasm/WasmModule @ &wasm_module . &types}}

    ; push function codes
    {i = 0}
    (loop (
        (if {i == (Vec/len &fn_bodies)} (break))

        {fn_body : Lole/Ir/FnBody = {Lole/Ir/FnBody @ (Vec/at &fn_bodies i)}}

        {&fn_type : (& Lole/Wasm/WasmFnType) = (Vec/at &fn_types {fn_body . type_index})}

        {&fn_ctx : (& Lole/Ir/FnContext) = (new Lole/Ir/FnContext (do
            &ctx
            &fn_type
            {fn_body . &locals}
            {fn_body . locals_last_index}
            (Vec/new 1 (sizeof Lole/Wasm/WasmType))
            (Dict/new 1 (sizeof Lole/Ast/SExpr))
        ))}

        ; let mut instrs = compile_block(&fn_body.body, &mut fn_ctx)?;
        ; if let Some(values) = get_deferred("return", &mut fn_ctx) {
        ;     instrs.append(&mut values?);
        ; };

        ; let mut locals = Vec::<WasmLocals>::new();
        ; for local_type in fn_ctx.non_arg_locals {
        ;     if let Some(wasm_locals) = locals.last_mut() {
        ;         if (*wasm_locals).value_type == local_type {
        ;             wasm_locals.count += 1;
        ;             continue;
        ;         }
        ;     }
        ;     locals.push(WasmLocals {
        ;         count: 1,
        ;         value_type: local_type.clone(),
        ;     });
        ; }

        ; ctx.wasm_module.codes.push(WasmFn {
        ;     locals,
        ;     expr: WasmExpr { instrs },
        ; });

        {i += 1}
    ))

    (return true 0)
))

; TODO: implement
(fn Lole/Compiler/compile_top_level_expr [
    (expr Lole/Ast/SExpr) (&ctx (& Lole/Ir/ModuleContext))
] [Lole/Compiler/CompileResult] (
    (if {expr . kind == (enum.kind Lole/Ast/SExpr/Atom)} (do
        (return false (new Lole/Ast/CompileError (do
            (String/from_slice "Unexpected atom")
            (Lole/Ast/Location/clone (Lole/Ast/SExpr/loc expr))
        )))
    ))

    (return true 0)
))
