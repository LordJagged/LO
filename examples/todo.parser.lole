;; TODO(COMPILER): implement type system
;; TODO(COMPILER): implement scoped locals
;; TODO(COMPILER): implement string_to_chars_vec
;; TODO(COMPILER): implement constants
;; TODO(COMPILER): support macros or hardcode `try!`
;; TODO(COMPILER): design struct creation
;; TODO(COMPILER): implement struct creation
;; TODO(USERLAND): define StringSlice type?
;; TODO(USERLAND): define Result, Vec, SExpr, ParseError types
;; TODO(USERLAND): implement `Vec/new`
;; TODO(USERLAND): implement `Vec/len`
;; TODO(USERLAND): implement `Result/ok` constructor
;; TODO(USERLAND): implement `try!`

(const L_PAREN 40)

(export parse :as parse)
(fn parse [(script StringSlice)] [(Result (Vec SExpr) ParseError)] (
    {chars := (string_to_chars_vec script)}
    {index := (skip_space chars 0)}
    {items := (Vec/new)}

    (loop (
        (if {index < (Vec/len chars)}
            (break)
        )

        (if {(try! (char_at chars index)) != L_PAREN}
            (return (Result/err (ParseError
                (kind (ParseErrorKind/UnexpectedChar))
                (index index)
            )))
        )

        {res := (try! (parse_list chars index))}
        (Vec/push items (ParseResult/data res))
        {index = (skip_space chars (ParseResult/index res))}
    ))

    ;; TODO: free chars
    ;; TODO: use defer?

    (Result/ok items)
))

(fn index_to_position [(chars StringSlice) (index i32)] [i32 i32] (
    {line := 0}
    {col := 0}
    {char_index := 0}

    (loop (
        (if {char_index < {chars . size}}
            (break)
        )

        (if {char_index == index}
            (break)
        )

        {char := (StringSlice/char_at chars index)}

        (if {char == '\n'} (do
            {col = 1}
            {line = {line + 1}}
            (continue)
        ))

        {col = {col + 1}}
    ))

    (pack line col)
))
