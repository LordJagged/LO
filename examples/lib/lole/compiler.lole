(mod lib/std)
(mod lib/lole/ir)
(mod lib/lole/parser)

(struct Lole/Compiler/CompileResult
    (ok bool)
    (data (& void)) ; 0 | (& Lole/Ast/CompileError)
)

(fn Lole/Compiler/compile [
    (exprs (& Vec<Lole/Ast/SExpr>)) (wasm_module (& Lole/Wasm/WasmModule))
] Lole/Compiler/CompileResult (
    {ctx := (Lole/Ir/ModuleContext/new wasm_module)}
    (defer (Lole/Ir/ModuleContext/free ctx))

    {i := 0}
    (loop (
        (if {i == {exprs -> size}} (
            (break)
        ))

        {res :=
            (Lole/Compiler/compile_top_level_expr
                {Lole/Ast/SExpr @ (Vec/at exprs i)}
                ctx
            )
        }
        (if (not {res . ok}) (
            (return res)
        ))

        {i += 1}
    ))

    {fn_defs := {ctx -> fn_defs}}
    {fn_exports := {ctx -> fn_exports}}

    ; push function exports
    {i = 0}
    (loop (
        (if {i == {fn_exports -> size}} (
            (break)
        ))

        {fn_export := {Lole/Ir/FnExport @ (Vec/at fn_exports i)}}

        {fn_def_res := (Dict/get fn_defs (Vec/as_slice {fn_export . in_name}))}
        (if (not {fn_def_res . ok}) (
            {msg := (String/from_slice "Cannot export unknown function: ")}
            (Vec/push_all msg (Vec/as_slice {fn_export . in_name}))

            (return (Lole/Compiler/CompileResult
                :ok false
                :data {(new Lole/Ast/CompileError (Lole/Ast/CompileError
                    :message msg
                    :loc (Lole/Ast/Location/clone {fn_export . loc})
                )) as (& void)}
            ))
        ))
        {fn_def := {Lole/Ir/FnDef @ {fn_def_res . value}}}

        {exports := {wasm_module -> exports}}

        {Lole/Wasm/WasmExport @ (Vec/push_undef exports) = (Lole/Wasm/WasmExport
            :export_type Lole/Wasm/WasmExportType/FUNC
            :export_name (String/clone {fn_export . out_name})
            :exported_item_index {ctx -> imported_fns_count + {fn_def . fn_index}}
        )}

        {i += 1}
    ))

    {fn_bodies := {ctx -> fn_bodies}}
    {fn_types := {wasm_module -> types}}

    ; push function codes
    {i = 0}
    (loop (
        (if {i == {fn_bodies -> size}} (
            (break)
        ))

        {fn_body := {Lole/Ir/FnBody @ (Vec/at fn_bodies i)}}

        {fn_type := {(Vec/at fn_types {fn_body . type_index})
            as (& Lole/Wasm/WasmFnType)}}

        {fn_ctx := (new Lole/Ir/FnContext (Lole/Ir/FnContext
            :module ctx
            :fn_type fn_type
            :locals {fn_body . locals}
            :locals_last_index {fn_body . locals_last_index}
            :non_arg_locals (Vec/new 1 (sizeof Lole/Wasm/WasmType))
            :defers (Dict/new 1 (sizeof Lole/Ast/SExpr))
        ))}

        {instrs_res := (Lole/Compiler/compile_block
            {fn_body . body} fn_ctx
        )}
        (if (not {instrs_res . ok}) (
            (return instrs_res)
        ))
        {instrs := {instrs_res . data as (& Vec)}}

        {deferred_res := (Lole/Compiler/get_deferred
            "return" ; TODO: this should be a constant
            fn_ctx
        )}
        (if {deferred_res . ok} (
            (Vec/append instrs {deferred_res . data})
            (Vec/free {deferred_res . data})
        ))

        {locals := (Vec/new 1 (sizeof Lole/Wasm/WasmLocals))}
        {non_arg_locals := {fn_ctx -> non_arg_locals}}

        {j := 0}
        (loop (
            (if {j == {non_arg_locals -> size}} (
                (break)
            ))

            {local_type := {Lole/Wasm/WasmType @ (Vec/at non_arg_locals j)}}
            {locals_len := {locals -> size}}
            (if {locals_len > 0} (
                {wasm_locals := {(Vec/at locals {locals_len - 1}) as (& Lole/Wasm/WasmLocals)}}
                (if {wasm_locals -> value_type == local_type} (
                    {wasm_locals -> count += 1}
                    (continue)
                ))
            ))

            {Lole/Wasm/WasmLocals @ (Vec/push_undef locals) = (Lole/Wasm/WasmLocals
                :count 1
                :value_type local_type
            )}

            {j += 1}
        ))

        {codes := {wasm_module -> codes}}
        {Lole/Wasm/WasmFn @ (Vec/push_undef codes) = (Lole/Wasm/WasmFn
            :locals locals
            :expr (Lole/Wasm/WasmExpr :instrs instrs)
        )}

        {i += 1}
    ))

    (return (Lole/Compiler/CompileResult :ok true :data {0 as (& void)}))
))

; TODO: implement
(fn Lole/Compiler/compile_top_level_expr [
    (expr Lole/Ast/SExpr) (ctx (& Lole/Ir/ModuleContext))
] Lole/Compiler/CompileResult (
    (if {expr . kind == Lole/Ast/SExpr/ATOM} (
        (return (Lole/Compiler/CompileResult
            :ok false
            :data {(new Lole/Ast/CompileError (Lole/Ast/CompileError
                :message (String/from_slice "Unexpected atom")
                :loc (Lole/Ast/Location/clone (Lole/Ast/SExpr/loc expr))
            )) as (& void)}
        ))
    ))

    (return (Lole/Compiler/CompileResult
        :ok true
        :data {0 as (& void)}
    ))
))

(struct Lole/Compiler/CompileBlockResult
    (ok bool)
    (data (& void)) ; (& Vec<Lole/Wasm/WasmInstr>) | (& Lole/Ast/CompileError)
)

; TODO: implement
(fn Lole/Compiler/compile_block [
    (exprs (& Vec<Lole/Ast/SExpr>)) (ctx (& Lole/Ir/ModuleContext))
] Lole/Compiler/CompileBlockResult (
    (return (Lole/Compiler/CompileBlockResult
        :ok true
        :data {0 as (& void)}
    ))
))

(struct Lole/Compiler/GetDefferedRes
    (ok bool)
    (data (& void)) ; (& Vec<Lole/Wasm/WasmInstr>) | (& Lole/Ast/CompileError)
)

; TODO: implement
(fn Lole/Compiler/get_deferred [
    (defer_label StringSlice) (ctx (& Lole/Ir/ModuleContext))
] Lole/Compiler/GetDefferedRes (
    (return (Lole/Compiler/GetDefferedRes
        :ok true
        :data {0 as (& void)}
    ))
))
