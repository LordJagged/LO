(mem m1 :min 1000)

;; exports for testing
(export mem m1 :as memory)
(export Vec/new :as vec_new)
(export Vec/get_u8 :as vec_get_u8)
(export Vec/len :as vec_len)
(export Vec/swap :as vec_swap)
(export Vec/push_u8 :as vec_push_u8)
(export Vec/push_all :as vec_push_all)

(struct &Vec (ref ptr))
(struct Vec
    (length u32)
    (capacity u32)
    (item_size u32)
    (data_ref ptr)
)

(fn Vec/new [(capacity u32) (item_size u32)] [&Vec] (
    {&self : &Vec}
    {&self = (alloc (sizeof Vec))}
    (store Vec &self (struct.new Vec
        0 capacity item_size
        (alloc {capacity * item_size})
    ))
    &self
))

;; TODO: check out of bounds
(fn Vec/get_u8 [(&self &Vec) (index u32)] [u8] (
    {self : Vec}
    {self = (load Vec &self)}

    (load i32/u8 {{self . data_ref} + {index * {self . item_size}}})
))

;; TODO: check out of bounds
(fn Vec/swap [(&self &Vec) (index1 u32) (index2 u32)] [] (
    {self : Vec}
    {self = (load Vec &self)}

    (memswap
        {{self . data_ref} + {index1 * {self . item_size}}}
        {{self . data_ref} + {index2 * {self . item_size}}}
        {self . item_size}
    )
))

(fn Vec/len [(&self &Vec)] [u32] (
    {self : Vec}
    {self = (load Vec &self)}

    {self . length}
))

(fn Vec/push_u8 [(&self &Vec) (item u8)] [] (
    {self : Vec}
    {self = (load Vec &self)}

    {index : u32}
    {index = {self . length}}

    {self = length {index + 1}} ; TODO: fix this ugly syntax
    (store Vec &self self)

    (Vec/grow_if_needed &self)

    {self = (load Vec &self)}

    (store i32/u8 {
        {self . data_ref} + {index * {self . item_size}}}
        item
    )
))

(fn Vec/push_all [(&self &Vec) (&items ptr) (items_len u32)] [] (
    {self : Vec}
    {self = (load Vec &self)}

    {old_len : u32}
    {old_len = {self . length}}

    {self = length {old_len + items_len}} ; TODO: fix this ugly syntax
    (store Vec &self self)

    (Vec/grow_if_needed &self)

    {self = (load Vec &self)}

    (memcpy
        &items
        {{self . data_ref} + {old_len * {self . item_size}}}
        {items_len * {self . item_size}}
    )
))

;; TODO: do not realloc if length is equal to capacity
(fn Vec/grow_if_needed [(&self &Vec)] [] (
    {self : Vec}
    {self = (load Vec &self)}

    (if {{self . length} == {self . capacity}} (do
        {new_cap : u32}
        {new_cap = {{self . capacity} * 2}}

        {old_data_ref : ptr}
        {old_data_ref = {self . data_ref}}

        {self = data_ref (alloc {new_cap * {self . item_size}})} ; TODO: fix this ugly syntax
        (memcpy old_data_ref {self . data_ref} {self . capacity})
        {self = capacity new_cap} ; TODO: fix this ugly syntax

        (free old_data_ref)
    ))

    (store Vec &self self)
))

;; utils

(global mut HEAP_INDEX u32 0)
(fn alloc [(size u32)] [ptr] (
    {ref : ptr}
    {ref = HEAP_INDEX}
    {HEAP_INDEX = {HEAP_INDEX + size}}
    ref
))

;; TODO: implement
(fn free [(ref ptr)] [] ())

(fn memcpy [(src ptr) (dist ptr) (size u32)] [] (
    (loop (
        (if {size == 0} (break))
        {size = {size - 1}}

        (store i32/u8 {dist + size} (load i32/u8 {src + size}))
    ))
))

(fn memswap [(ref1 ptr) (ref2 ptr) (size u32)] [] (
    (loop (
        (if {size == 0} (break))
        {size = {size - 1}}

        {tmp : u8}
        {tmp = (load i32/u8 {ref1 + size})}
        (store i32/u8 {ref1 + size} (load i32/u8 {ref2 + size}))
        (store i32/u8 {ref2 + size} tmp)
    ))
))
