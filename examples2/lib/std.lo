// panic

    fn panic(message_ptr: &*u8, message_len: u32) {
        // TODO: &&*u8 should be parsed fine without a space
        *(0 as & &*u8) = message_ptr;
        *(4 as &u32) = message_len;
        unreachable;
    };

// alloc

    const ALLOC_STACK = 0;
    const ALLOC_HEAP  = 1;

    fn alloc(alloc_id: u32, size: u32) -> &() {
        if alloc_id == 0 {
            return Stack_alloc(size);
        };

        return Heap_alloc(size);
    };

    fn free(alloc_id: u32, ptr: &(), size: u32) {
        if alloc_id == 0 {
            return Stack_free(size);
        };

        return Heap_free(ptr);
    };

// memory instructions

    const MEM_POINTER_SIZE = 4;
    const MEM_PAGE_SIZE = 65536;

    fn Mem_align(size: u32) -> u32 {
        return Mem_align_to(size, MEM_POINTER_SIZE);
    };

    fn Mem_align_to(size: u32, size_multiple: u32) -> u32 {
        let remaining_to_align = size % size_multiple;
        if remaining_to_align == 0 {
            return size;
        };

        let padding = size_multiple - remaining_to_align;
        return size + padding;
    };

    // TODO: use builtin mem.copy instr, check engine support
    fn Mem_copy(src: &(), dist: &(), size: u32) {
        loop {
            if size == 0 {
                break;
            };

            size -= 1;

            *((dist + size) as &u8) = *((src + size) as &u8);
        };
    };

    fn Mem_swap(ref1: &(), ref2: &(), size: u32) {
        loop {
            if size == 0 {
                break;
            };

            size -= 1;

            let tmp = *((ref1 + size) as &u8);
            *((ref1 + size) as &u8) = *((ref2 + size) as &u8);
            *((ref2 + size) as &u8) = tmp;
        };
    };

// stack

    let Stack_CURRENT = __DATA_SIZE__;
    let STACK_BEGIN = __DATA_SIZE__; // TODO: this should be const
    const STACK_END = 1_048_576; // 1MB, ~20 pages (65_536b)

    fn Stack_push_u32(value: u32) {
        *(Stack_alloc(sizeof u32) as &u32) = value;
    };

    fn Stack_read_u32() -> u32 {
        return *((Stack_CURRENT - sizeof u32) as &u32);
    };

    fn Stack_pop_u32() -> u32 {
        Stack_free(sizeof u32);

        return *(Stack_CURRENT as &u32);
    };

    fn Stack_alloc(size: u32) -> &() {
        Stack_CURRENT += size;

        if Stack_CURRENT > STACK_END {
            panic("Stack overflow");
        };

        return (Stack_CURRENT - size) as &();
    };

    fn Stack_free(size: u32) {
        Stack_CURRENT -= size;

        if Stack_CURRENT < STACK_BEGIN {
            panic("Stack underflow");
        };
    };

// heap

    struct Heap_Block {
        size: u32,
        used: bool,
        next: & Heap_Block,
        data: &(),
    };

    let Heap_TOTAL_ALLOCATED = STACK_END;
    let Heap_FIRST_BLOCK = 0 as &Heap_Block;
    let Heap_CURRENT_BLOCK = 0 as &Heap_Block;

    // http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/#mutator-allocator-collector
    fn Heap_alloc(size: u32) -> &() {
        size = Mem_align(size);

        let free_block = Heap_find_free_block(size);
        if free_block != 0 {
            free_block->used = true;
            return free_block->data;
        };

        let total_size_to_alloc = size + sizeof Heap_Block;

        let block = Heap_TOTAL_ALLOCATED as &Heap_Block;
        Heap_TOTAL_ALLOCATED += total_size_to_alloc;

        // grow enough memory if we are out of space
        if Heap_TOTAL_ALLOCATED >= __memory_size() * MEM_PAGE_SIZE {
            let pages_to_grow = Mem_align_to(total_size_to_alloc, MEM_PAGE_SIZE);
            let grow_res = __memory_grow(pages_to_grow);
            if grow_res == (0 - 1) {
                panic("OOM");
            };
        };

        block->size = size;
        block->used = true;
        block->data = (block + sizeof Heap_Block) as &();

        // init heap
        if Heap_FIRST_BLOCK == 0 {
            Heap_FIRST_BLOCK = block;
        };

        // chain block
        if Heap_CURRENT_BLOCK != 0 {
            Heap_CURRENT_BLOCK->next = block;
        };

        Heap_CURRENT_BLOCK = block;

        return block->data;
    };

    fn Heap_free(ptr: & ()) {
        let block = Heap_get_block(ptr);
        block->used = false;
    };

    fn Heap_get_block(ptr: &()) -> &Heap_Block {
        return (ptr - sizeof Heap_Block) as &Heap_Block;
    };

    // first fit
    fn Heap_find_free_block(size: u32) -> &Heap_Block {
        let block = Heap_FIRST_BLOCK;

        loop {
            if block == 0 || (!block->used && block->size >= size) {
                break;
            };

            block = block->next;
        };

        return block;
    };

// vec

    struct Vec {
        data: &(),
        size: u32,
        capacity: u32,
        item_size: u32,
        alloc_id: u32,
    };

    fn Vec_new(capacity: u32, item_size: u32) -> &Vec {
        return Vec_new_using(capacity, item_size, ALLOC_HEAP);
    };

    fn Vec_new_using(capacity: u32, item_size: u32, alloc_id: u32) -> &Vec {
        // TODO: look into `new`
        let self_ptr = alloc(alloc_id, sizeof Vec) as &Vec;
        *self_ptr = Vec {
            data: alloc(alloc_id, capacity * item_size),
            size: 0,
            capacity: capacity,
            item_size: item_size,
            alloc_id: alloc_id,
        };
        return self_ptr;
    };

    fn Vec_free(self: &Vec) {
        free(self->alloc_id, self, sizeof Vec);
        free(self->alloc_id, self->data, self->capacity);
    };

    struct Slice {
        data: &(),
        size: u32,
    };

    fn Vec_as_slice(self: &Vec) -> Slice {
        return Slice {
            data: self->data,
            size: self->size,
        };
    };

    fn Vec_at(self: &Vec, index: u32) -> &() {
        Vec__panic_if_out_of_bounds(self, index);

        return self->data + index * self->item_size;
    };

    fn Vec_at_unchecked(self: &Vec, index: u32) -> &() {
        return self->data + index * self->item_size;
    };

    fn Vec_swap(self: &Vec, index1: u32, index2: u32) {
        Vec__panic_if_out_of_bounds(self, index1);
        Vec__panic_if_out_of_bounds(self, index2);

        let item_size = self->item_size;
        Mem_swap(
            self->data + index1 * item_size,
            self->data + index2 * item_size,
            item_size,
        );
    };

    fn Vec_push(self: &Vec) -> &() {
        self->size += 1;
        Vec__grow_if_needed(self);

        return Vec_at_unchecked(self, self->size - 1);
    };

    fn Vec_push_all(self: &Vec, items: &(), items_len: u32) {
        let old_len = self->size;
        self->size = old_len + items_len;

        Vec__grow_if_needed(self);

        Mem_copy(
            items,
            self->data + old_len * self->item_size,
            items_len * self->item_size,
        );
    };

    fn Vec_append(self: &Vec, other: &Vec) {
        Vec_push_all(self, other->data, other->size);
        other->size = 0;
    };

    fn Vec_pop_unchecked(self: &Vec) -> &() {
        self->size -= 1;
        return Vec_at_unchecked(self, self->size);
    };

    fn Vec_reverse(self: &Vec) {
        let start = 0;
        let end = self->size - 1;

        loop {
            if start >= end {
                break;
            };

            Vec_swap(self, start, end);
            start += 1;
            end -= 1;
        };
    };

    fn Vec__grow_if_needed(self: &Vec) {
        if self->size != self->capacity {
            return;
        };

        if self->alloc_id == ALLOC_STACK {
            panic("Attempt to grow stack allocated vector");
        };

        let item_size = self->item_size;
        let old_capacity = self->capacity;
        let old_data = self->data;
        defer free(self->alloc_id, old_data, old_capacity);

        self->capacity = old_capacity * 2;
        self->data = alloc(self->alloc_id, self->capacity * item_size);

        Mem_copy(old_data, self->data, self->size * item_size);
    };

    fn Vec__panic_if_out_of_bounds(self: &Vec, index: u32) {
        if index < 0 || index >= self->size {
            panic("Vec access out of bounds");
        };
    };

// string

    type Vec_u8 = Vec;
    type String = Vec_u8;
    
    struct StringSlice {
        data: &*u8,
        size: u32,
    };

    fn String_new(len: u32) -> &String {
        return Vec_new(len, sizeof u8);
    };

    fn String_new_using(len: u32, alloc_id: u32) -> &String {
        return Vec_new_using(len, sizeof u8, alloc_id);
    };

    fn StringSlice_char_at(self: StringSlice, index: u32) -> u8 {
        return *((self.data + index) as &u8);
    };

    fn StringSlice_clone(self: StringSlice) -> StringSlice {
        let cloned_data = Heap_alloc(self.size) as &*u8;
        Mem_copy(self.data, cloned_data, self.size);
        return StringSlice {
            data: cloned_data,
            size: self.size,
        };
    };

    fn StringSlice_equals(self: StringSlice, other: StringSlice) -> bool {
        if self.size != other.size {
            return false;
        };

        let i = 0;
        loop {
            if i == self.size {
                break;
            };

            if *((self.data + i) as &u8) != *((other.data + i) as &u8) {
                return false;
            };

            i += 1;
        };

        return true;
    };

    fn String_clone(self: &String) -> &String {
        return String_from_slice(self->data, self->size);
    };

    fn String_from_slice(str_slice: StringSlice) -> &String {
        let string = String_new(str_slice.size);
        Vec_push_all(string, str_slice);
        return string;
    };

// dict

    type Dict = Vec;

    fn Dict_new(initial_capacity: u32, value_size: u32) -> &Dict {
        return Vec_new(initial_capacity, value_size + sizeof String);
    };

    fn Dict_free(self: &Dict) {
        Vec_free(self);
    };

    struct Dict_GetResult {
        ok: bool,
        value: &(),
    };

    fn Dict_get(self: &Dict, key: StringSlice) -> Dict_GetResult {
        let i = 0;
        loop {
            if i == self->size {
                break;
            };

            let entry_key = Vec_at(self, i) as &String;
            if StringSlice_equals(key, Vec_as_slice(entry_key)) {
                return Dict_GetResult {
                    ok: true,
                    value: (entry_key + sizeof String) as &(),
                };
            };

            i += 1;
        };

        return Dict_GetResult { ok: false, value: 0 as &() };
    };

// conversions

    fn std_u32_to_string(input: u32) -> &String {
        return std_u32_to_string_using(input, ALLOC_HEAP);
    };

    fn std_u32_to_string_using(input: u32, alloc_id: u32) -> &String {
        let output = String_new_using(32, alloc_id);

        if input == 0 {
            *(Vec_push(output) as &u8) = char_code "0" as u8;
            return output;
        };

        loop {
            let rem = input % 10;

            *(Vec_push(output) as &u8) = (char_code "0" + rem) as u8;
            input = input / 10;

            if input == 0 {
                break;
            };
        };

        Vec_reverse(output);

        return output;
    };

    fn std_c_str_to_slice(str: &*u8) -> StringSlice {
        let len = 0;

        loop {
            if *((str + len) as &u8) == 0 {
                break;
            };

            len += 1;
        };

        return StringSlice { data: str, size: len };
    };
