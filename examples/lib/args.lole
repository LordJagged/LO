(struct Args
    (argc u32)
    (&argv ptr) ;; &*&*u8, // TODO: can be solved with aliases
)

(fn Args/load [] [Args] (
    {&argc : &u32 = (Stack/alloc (sizeof u32))}
    {&argv_buf_size : &u32 = (Stack/alloc (sizeof u32))}
    (drop (args_sizes_get &argc &argv_buf_size))

    {argc : u32 = {i32 @ &argc}}
    {&argv : &*&*u8 = (Mem/alloc {argc * (sizeof &*u8)})}
    {&argv_buf : &*u8 = (Mem/alloc {i32 @ &argv_buf_size})}
    (drop (args_get &argv &argv_buf))

    (Stack/free (sizeof u32))
    (Stack/free (sizeof u32))

    (return (struct.new Args argc &argv))
))

(fn Args/get [(self Args) (i u32)] [StringSlice] (
    {&arg : &*u8 = {i32 @ {self . &argv} @ {i * (sizeof &*u8)}}}
    (return (struct.new StringSlice
        &arg (Args/_c_str_len &arg)
    ))
))

(fn Args/_c_str_len [(&str &*u8)] [u32] (
    {len : u32 = 0}

    (loop (
        (if {{i32/u8 @ &str @ len} == 0} (break))

        {len = {len + 1}}
    ))

    (return len)
))
