(mem m1 :min 1000)
(export mem m1 :as memory)

(export parse :as parse)
(export skip_space :as skip_space)
(export char_at :as char_at)

(struct StringSlice
    (data i32)
    (size i32)
)

(fn StringSlice/char_at ((self StringSlice) (index i32)) (i32) (
    (i32.load8_u (i32.add (get self :data) index))
))

; TODO: implement
(fn parse ((script StringSlice)) (
    i32 ; ok
    i32 ; index
) (
    (return (i32 0) (i32 0))
))

; TODO: add support for comments
(fn skip_space ((chars StringSlice) (index i32)) (
    i32 ; index
) (
    (let res CharAtResult)

    (loop (
        (set res (char_at chars index))

        (if (i32.ne (get res :ok) (i32 1))
            (break)
        )

        (if (i32.ne (get res :char) (i32 32)) ; space
            (break)
        )

        (set index (i32.add index (i32 1)))
    ))

    index
))

(struct CharAtResult
    (ok i32)
    (char i32)
)

(fn char_at ((chars StringSlice) (index i32)) (CharAtResult) (
    (if (i32.ge_s index (get chars :size))
        (return (new CharAtResult (i32 0) (i32 0)))
    )

    (new CharAtResult (i32 1) (StringSlice/char_at chars index))
))
