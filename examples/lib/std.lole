; panic

    (fn panic [(message_ptr (&* u8)) (message_len u32)] void (
        {(&* u8) @ 0 = message_ptr}
        {u32 @ 4 = message_len}
        (unreachable)
    ))

; alloc

    (alias Alloc/STACK 0)
    (alias Alloc/HEAP 1)

    (fn alloc [(alloc_id u32) (size u32)] (& void) (
        (if {alloc_id == 0} (return (Stack/alloc size)))
        (return (Heap/alloc size))
    ))

    (fn free [(alloc_id u32) (ptr (& void)) (size u32)] void (
        (if {alloc_id == 0} (return (Stack/free size)))
        (return (Heap/free ptr))
    ))

; memory instructions

    (alias Mem/POINTER_SIZE 4)
    (alias Mem/PAGE_SIZE 65536)

    (fn Mem/align [(size u32)] u32 (
        (return (Mem/align_to size Mem/POINTER_SIZE))
    ))

    (fn Mem/align_to [(size u32) (size_multiple u32)] u32 (
        {remaining_to_align := {size % size_multiple}}
        (if {remaining_to_align == 0} (do
            (return size)
        ))

        {padding := {size_multiple - remaining_to_align}}
        (return {size + padding})
    ))

    ; TODO: use builtin mem.copy instr, check engine support
    (fn Mem/copy [(src (& void)) (dist (& void)) (size u32)] void (
        (loop (
            (if {size == 0} (break))
            {size -= 1}

            {u8 @ {dist + size} = {u8 @ {src + size}}}
        ))
    ))

    (fn Mem/swap [(ref1 (& void)) (ref2 (& void)) (size u32)] void (
        (loop (
            (if {size == 0} (break))
            {size -= 1}

            {
            (do {u8 @ {ref1 + size}}
                {u8 @ {ref2 + size}})
                =
            (do {u8 @ {ref2 + size}}
                {u8 @ {ref1 + size}})
            }
        ))
    ))

; stack

    (global mut Stack/&CURRENT u32 (data.size))
    (global mut Stack/&BEGIN (& void) (data.size))
    (global mut Stack/&END u32 1048576) ; 1MB

    (fn Stack/push_u32 [(value u32)] void (
        {u32 @ (Stack/alloc (sizeof u32)) = value}
    ))

    (fn Stack/read_u32 [] u32 (
        (return {u32 @ {Stack/&CURRENT - (sizeof u32)}})
    ))

    (fn Stack/pop_u32 [] u32 (
        (Stack/free (sizeof u32))

        (return {u32 @ Stack/&CURRENT})
    ))

    (fn Stack/alloc [(size u32)] (& void) (
        {Stack/&CURRENT += size}

        (if {Stack/&CURRENT > Stack/&END} (do
            (panic "Stack overflow")
        ))

        (return {Stack/&CURRENT - size})
    ))

    (fn Stack/free [(size u32)] void (
        {Stack/&CURRENT -= size}

        (if {Stack/&CURRENT < Stack/&BEGIN} (do
            (panic "Stack underflow")
        ))
    ))

; heap

    (struct Heap/Block
        (size u32)
        (used bool)
        (&next (& Heap/Block))
        (&data (& void))
    )

    (global mut Heap/TOTAL_ALLOCATED u32 1048576) ; starts after stack end
    (global mut Heap/&FIRST_BLOCK (& Heap/Block) 0)
    (global mut Heap/&CURRENT_BLOCK (& Heap/Block) 0)

    ; http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/#mutator-allocator-collector
    (fn Heap/alloc [(size u32)] (& void) (
        {size = (Mem/align size)}

        {&free_block := (Heap/find_free_block size)}
        (if {&free_block != 0} (do
            {&free_block -> used = true}
            (return {&free_block -> &data})
        ))

        {total_size_to_alloc := {size + (sizeof Heap/Block)}}

        {&block := {Heap/TOTAL_ALLOCATED as (& Heap/Block)}}
        {Heap/TOTAL_ALLOCATED += total_size_to_alloc}

        ; memory.grow enough if out of space
        (if {Heap/TOTAL_ALLOCATED >= {(memory.size) * Mem/PAGE_SIZE}} (do
            {pages_to_grow := (Mem/align_to total_size_to_alloc Mem/PAGE_SIZE)}
            {grow_res := (memory.grow pages_to_grow)}
            (if {grow_res == {0 - 1}} (do
                (panic "OOM")
            ))
        ))

        {&block -> size = size}
        {&block -> used = true}
        {&block -> &data = {&block + (sizeof Heap/Block) as (& void)}}

        ; init heap
        (if {Heap/&FIRST_BLOCK == 0} (do
            {Heap/&FIRST_BLOCK = &block}
        ))

        ; chain block
        (if {Heap/&CURRENT_BLOCK != 0} (do
            {Heap/&CURRENT_BLOCK -> &next = &block}
        ))

        {Heap/&CURRENT_BLOCK = &block}

        (return {&block -> &data})
    ))

    (fn Heap/free [(&ref (& void))] void (
        {&block := (Heap/get_block &ref)}
        {&block -> used = false}
    ))

    (fn Heap/get_block [(&ref (& void))] (& Heap/Block) (
        (return {&ref - (sizeof Heap/Block)})
    ))

    ; first fit
    (fn Heap/find_free_block [(size u32)] (& Heap/Block) (
        {&block := Heap/&FIRST_BLOCK}

        (loop (
            (if {&block == 0} (break))

            (if {(not {&block -> used}) && {&block -> size >= size}} (do
                (return &block)
            ))

            {&block = {&block -> &next}}
        ))

        (return 0)
    ))

; vec

    (struct Vec
        (&data (& void))
        (length u32)
        (capacity u32)
        (item_size u32)
        (alloc_id u32)
    )

    (fn Vec/new [(capacity u32) (item_size u32)] (& Vec) (
        (return (Vec/new_using capacity item_size Alloc/HEAP))
    ))

    (fn Vec/new_using [(capacity u32) (item_size u32) (alloc_id u32)] (& Vec) (
        (return (new Vec (do
            (alloc alloc_id {capacity * item_size})
            0
            capacity
            item_size
            alloc_id
        ) :using alloc_id))
    ))

    (fn Vec/free [(&self (& Vec))] void (
        (free {&self -> alloc_id} &self (sizeof Vec))
        (free {&self -> alloc_id} {&self -> &data} {&self -> capacity})
    ))

    (fn Vec/len [(&self (& Vec))] u32 (
        (return {&self -> length})
    ))

    (struct Slice
        (data (& void))
        (size u32)
    )

    (fn Vec/as_slice [(&self (& Vec))] Slice (
        (return (Slice
            :data {&self -> &data}
            :size {&self -> length}
        ))
    ))

    (fn Vec/at [(&self (& Vec)) (index u32)] u32 (
        (Vec/_panic_if_out_of_bounds &self index)

        (return {&self -> &data + {index * {&self -> item_size}}})
    ))

    (fn Vec/at_unchecked [(&self (& Vec)) (index u32)] u32 (
        (return {&self -> &data + {index * {&self -> item_size}}})
    ))

    (fn Vec/get_u8 [(&self (& Vec)) (index u32)] u8 (
        (Vec/_panic_if_out_of_bounds &self index)

        (return {u8 @ {&self -> &data + {index * {&self -> item_size}}}})
    ))

    (fn Vec/swap [(&self (& Vec)) (index1 u32) (index2 u32)] void (
        (Vec/_panic_if_out_of_bounds &self index1)
        (Vec/_panic_if_out_of_bounds &self index2)

        {item_size := {&self -> item_size}}
        (Mem/swap
            {&self -> &data + {index1 * item_size}}
            {&self -> &data + {index2 * item_size}}
            item_size
        )
    ))

    (fn Vec/push_u8 [(&self (& Vec)) (item u8)] void (
        {index := {&self -> length}}
        {&self -> length = {index + 1}}

        (Vec/_grow_if_needed &self)

        {u8 @ {&self -> &data + {index * {&self -> item_size}}} = item}
    ))

    (fn Vec/push_all [(&self (& Vec)) (&items (& void)) (items_len u32)] void (
        {old_len := {&self -> length}}
        {&self -> length = {old_len + items_len}}

        (Vec/_grow_if_needed &self)

        (Mem/copy
            &items
            {&self -> &data + {old_len * {&self -> item_size}}}
            {items_len * {&self -> item_size}}
        )
    ))

    (fn Vec/push_undef [(&self (& Vec))] (& void) (
        {&self -> length += 1}

        (Vec/_grow_if_needed &self)

        (return (Vec/at &self {&self -> length - 1}))
    ))

    (fn Vec/append [(&self (& Vec)) (&other (& Vec))] void (
        (Vec/push_all &self {&other -> &data} (Vec/len &other))
        ; TODO: ? add number inference
        {&other -> length = 0}
    ))

    (fn Vec/pop_unchecked [(&self (& Vec))] (& void) (
        {&self -> length -= 1}
        (return (Vec/at_unchecked &self (Vec/len &self)))
    ))

    (fn Vec/reverse [(&self (& Vec))] void (
        {start := 0}
        {end := {(Vec/len &self) - 1}}

        (loop (
            (if {start >= end} (break))

            (Vec/swap &self start end)
            {start += 1}
            {end -= 1}
        ))
    ))

    (fn Vec/_grow_if_needed [(&self (& Vec))] void (
        (if {&self -> length != {&self -> capacity}} (do
            (return)
        ))

        (if {&self -> alloc_id == Alloc/STACK} (do
            (panic "Attempt to grow stack allocated vector")
        ))

        {item_size := {&self -> item_size}}
        {old_capacity := {&self -> capacity}}
        {&old_data := {&self -> &data}}
        (defer (free {&self -> alloc_id} &old_data old_capacity))

        {&self -> capacity = {old_capacity * 2}}
        {&self -> &data = (alloc {&self -> alloc_id} {&self -> capacity * item_size})}

        (Mem/copy &old_data {&self -> &data} {&self -> length * item_size})
    ))

    (fn Vec/_panic_if_out_of_bounds [(&self (& Vec)) (index u32)] void (
        (if {{index < 0} || {index >= (Vec/len &self)}} (do
            (panic "Vec access out of bounds")
        ))
    ))

; string

    (alias Vec<u8> Vec)
    (alias String Vec<u8>)
    (struct StringSlice (data (&* u8)) (size u32))

    (fn String/new [(len u32)] (& String) (
        (return (Vec/new len (sizeof u8)))
    ))

    (fn String/new_using [(len u32) (alloc_id u32)] (& String) (
        (return (Vec/new_using len (sizeof u8) alloc_id))
    ))

    (fn StringSlice/char_at [(self StringSlice) (index u32)] u8 (
        (return {u8 @ {self . data + index}})
    ))

    (fn StringSlice/clone [(self StringSlice)] StringSlice (
        {&cloned_data := {(Heap/alloc {self . size}) as (&* u8)}}
        (Mem/copy {self . data} &cloned_data {self . size})
        (return (StringSlice :data &cloned_data :size {self . size}))
    ))

    (fn StringSlice/equals [(self StringSlice) (other StringSlice)] bool (
        (if {self . size != {other . size}} (do
            (return false)
        ))

        {i := 0}
        (loop (
            (if {i == {self . size}} (break))

            (if {u8 @ {self . data + i} != {u8 @ {other . data + i}}} (do
                (return false)
            ))

            {i += 1}
        ))

        (return true)
    ))

    (fn String/clone [(&self (& String))] (& String) (
        (return (String/from_slice {&self -> &data} {&self -> length}))
    ))

    (fn String/from_slice [(str StringSlice)] (& String) (
        {&string := (String/new {str . size})}
        (Vec/push_all &string str)
        (return &string)
    ))

; dict

    (alias Dict Vec)

    (fn Dict/new [(initial_capacity u32) (value_size u32)] (& Dict) (
        (return (Vec/new initial_capacity {value_size + (sizeof String)}))
    ))

    (fn Dict/free [(&self (& Dict))] void (
        (Vec/free &self)
    ))

    (fn Dict/len [(&self (& Dict))] u32 (
        (return (Vec/len &self))
    ))

    (struct Dict/GetResult (ok bool) (&value (& void)))

    (fn Dict/get [(&self (& Dict)) (key StringSlice)] Dict/GetResult (
        {i := 0}
        (loop (
            (if {i == (Dict/len &self)} (break))

            {&entry_key := {(Vec/at &self i) as (& String)}}
            (if (StringSlice/equals key (Vec/as_slice &entry_key)) (do
                (return (Dict/GetResult
                    :ok true
                    :&value {&entry_key + (sizeof String) as (& void)}
                ))
            ))

            {i += 1}
        ))

        (return (Dict/GetResult :ok false :&value {0 as (& void)}))
    ))

; conversions

    (fn std/u32_to_string [(input u32)] (& String) (
        (return (std/u32_to_string_using input Alloc/HEAP))
    ))

    (fn std/u32_to_string_using [(input u32) (alloc_id u32)] (& String) (
        {&output := (String/new_using 32 alloc_id)}

        (if {input == 0} (do
            (Vec/push_u8 &output (char_code "0"))
            (return &output)
        ))

        (loop (
            {rem := {input % 10}}

            (Vec/push_u8 &output {(char_code "0") + rem})
            {input = {input / 10}}

            (if {input == 0} (break))
        ))

        (Vec/reverse &output)

        (return &output)
    ))

    (fn std/c_str_to_slice [(&str (&* u8))] StringSlice (
        {len := 0}

        (loop (
            (if {{u8 @ {&str + len}} == 0} (break))

            {len += 1}
        ))

        (return (StringSlice :data &str :size len))
    ))
