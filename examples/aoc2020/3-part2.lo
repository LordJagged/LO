include "lib/cli";
include "lib/fs";

type Tile = bool;
const Tile::TREE = true;
const Tile::EMPTY = false;

fn main() {
    let input = fs::read_file("./aoc2020/3.txt");
    defer input.free();

    let map = Map::parse(input);
    defer map.free();

    let result = 1u64
        * map.count_trees_on_slope(1, 1) as u64
        * map.count_trees_on_slope(1, 3) as u64
        * map.count_trees_on_slope(1, 5) as u64
        * map.count_trees_on_slope(1, 7) as u64
        * map.count_trees_on_slope(2, 1) as u64;

    print_u64(result);
    puts("\n");
};

type Vec::Tile = Vec;
type Vec::Vec::Tile = Vec;

struct Map {
    cols: &Vec::Vec::Tile,
};

fn Map::parse(input: &String) -> Map {
    let cols = Vec::new!<&Vec::Tile>();
    let row = Vec::new!<Tile>();

    for i in 0..input->size {
        let char = input.get!<u8>(i);
        if char == '#' as u8 {
            row.push!<Tile>(Tile::TREE);
        };
        if char == '.' as u8 {
            row.push!<Tile>(Tile::EMPTY);
        };
        if char == '\n' as u8 {
            cols.push!<&Vec::Tile>(row);
            row = Vec::new!<Tile>();
        };
    };

    return Map { cols: cols };
};

fn Map::count_trees_on_slope(self, slope_i: u32, slope_j: u32) -> u32 {
    let tree_count = 0;
    let i = 0;
    let j = 0;

    loop {
        i += slope_i;
        j += slope_j;

        if i >= self.cols->size {
            break;
        };

        if self.get(i, j) == Tile::TREE {
            tree_count += 1;
        };
    };

    return tree_count;
};

fn Map::get(self, i: u32, j: u32) -> Tile {
    // TODO: this is not working:
    // let row = self.rows.get!<&Vec::Tile>(i);
    let row = *(self.cols.at(i) as & &Vec::Tile);
    return *(row.at(j % row->size) as &Tile);
};

fn Map::free(self) {
    for i in 0..self.cols->size {
        // TODO: this is not working:
        // let row = self.rows.get!<&Vec::Tile>(i);
        let row = *(self.cols.at(i) as & &Vec::Tile);
        row.free();
    };
    self.cols.free();
};
