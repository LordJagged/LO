include "../std.lo";
include "../fs.lo";
include "../string_map.lo";

include "./utils.lo";
include "./wasm.lo";
include "./ir.lo";

type Vec::LoIncludedFile = Vec;
struct LoIncludedFile {
    path: &String,
    contents: &String,
};

// TODO: add free
struct LoContext {
    included_files: &Vec::LoIncludedFile,
    wasm_module: &WasmModule,
    fn_defs: StringMap::LoFnDef,
    fn_exports: &Vec::LoFnExport,
    fn_bodies: &Vec::LoFnBody,
    imported_fns_count: u32,
};

fn LoContext::new(): &LoContext {
    return heap::new!<LoContext>(LoContext {
        included_files: Vec::new!<LoIncludedFile>(),
        wasm_module: WasmModule::new(),
        fn_defs: StringMap::new!<LoFnDef>(),
        fn_exports: Vec::new!<LoFnExport>(),
        fn_bodies: Vec::new!<LoFnBody>(),
        imported_fns_count: 0,
    });
};

fn LoContext::print_loc(&self, loc: LoLocation) {
    if loc.file_index == u32::MAX {
        eputs("<internal>");
    } else {
        let file = self.included_files.get!<LoIncludedFile>(loc.file_index);
        eprint_str(file.path as &str);
    };
    eputs(":");
    eprint_u32(loc.pos.line);
    eputs(":");
    eprint_u32(loc.pos.col);
};

// this is kinda ugly but parser depends on LoContext
// so it must be defined before parser
// TODO: is there a clean way to resolve this?
include "./parser.lo";

fn LoContext::include_file_and_finalize(&self, file_path: str): u32 throws &LoError {
    let file_index = LoContext::include_file(self, file_path) catch err {
        throw err;
    };

    LoParser::finalize(self) catch err {
        throw err;
    };

    return file_index;
};

fn LoContext::include_file(&self, file_path: str): u32 throws &LoError {
    let file_contents = fs::read_file(file_path) catch err {
        let message = String::from_str("Cannot include file: ");
        message.push_all(file_path.data as &void, file_path.size);
        message.push!<u8>('\n' as u8);

        throw heap::new!<LoError>(LoError {
            message: message,
            loc: LoLocation::internal(),
        });
    };

    self.included_files.push!<LoIncludedFile>(LoIncludedFile {
        path: String::from_str(file_path),
        contents: file_contents,
    });

    let file_index = self.included_files.size - 1;

    LoParser::parse_file(self, file_index, str::from_string(file_contents)) catch err {
        throw err;
    };

    return file_index;
};

fn LoContext::get_file(&self, file_index: u32): &LoIncludedFile {
    return self.included_files.at!<LoIncludedFile>(file_index);
};


fn LoContext::insert_fn_type(&self, fn_type: WasmFnType): u32 {
    for type_index in 0..self.wasm_module.types.size {
        if self.wasm_module.types.get!<WasmFnType>(type_index).equals(fn_type) {
            return type_index;
        };
    };

    self.wasm_module.types.push!<WasmFnType>(fn_type);
    return self.wasm_module.types.size - 1;
};

// TODO: implement
// TODO: where should this be defined?
fn WasmFnType::equals(self, other: WasmFnType): bool {
    return false;
};
