(mod lib/wasi)

; wasi_io expects host to preopen "." on fd 3
(alias CWD_PREOPEN_FD 3)

(fn WasiIO/fd_read_all [(fd u32)] (& String) (
    {output := (Vec/new 256 (sizeof u8))}
    {chunk := {(Stack/alloc 256) as (&* u8)}}
    (defer (Stack/free 256))

    {in_vec := (new Wasi/IOVec (Wasi/IOVec :base chunk :size 256)
        :using Alloc/STACK)}
    (defer (Stack/free (sizeof Wasi/IOVec)))

    {nread_ref := (new u32 0 :using Alloc/STACK)}
    (defer (Stack/free (sizeof u32)))

    (loop (
        {err := (Wasi/fd_read fd in_vec 1 nread_ref)}

        {nread := (* nread_ref)}

        (if {nread == 0} (
            (break)
        ))

        (Vec/push_all output chunk nread)
    ))

    (return output)
))

(fn WasiIO/fd_pipe [(fd_in u32) (fd_out u32) (chunk_size u32)] bool (
    {chunk := {(Stack/alloc chunk_size) as (&* u8)}}
    (defer (Stack/free chunk_size))

    {iov := (new Wasi/IOVec (Wasi/IOVec :base chunk :size 0) :using Alloc/STACK)}
    (defer (Stack/free (sizeof Wasi/IOVec)))

    {nread_ref := {(Stack/alloc (sizeof u32)) as (& u32)}}
    (defer (Stack/free (sizeof u32)))

    (loop (
        {iov -> size = chunk_size}
        {io_res := (Wasi/fd_read fd_in iov 1 nread_ref)}
        (if {io_res != 0} (
            (return false)
        ))

        {nread := (* nread_ref)}
        (if {nread == 0} (
            (break)
        ))

        {iov -> size = nread}
        {io_res = (Wasi/fd_write fd_out iov 1 nread)}
        (if {io_res != 0} (
            (return false)
        ))
    ))

    (return true)
))

(struct FdOpenRes
    (err Wasi/Err)
    (fd u32)
)

(fn WasiIO/fd_open [(file_path StringSlice)] FdOpenRes (
    {fd_ref := (new u32 0 :using Alloc/STACK)}
    (defer (Stack/free (sizeof u32)))

    {err := (Wasi/path_open
        CWD_PREOPEN_FD 0
        file_path 0 (i64 2) (i64 0) 0
        fd_ref
    )}

    (return (FdOpenRes :err err :fd (* fd_ref)))
))
