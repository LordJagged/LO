(mem m1 :min 1000)

(export Parser/parse :as parse)

;; exporting for testing
(export mem m1 :as memory)
(export Parser/skip_space :as skip_space)
(export Parser/char_at :as char_at)
(export Parser/index_to_position :as index_to_position)

(global true bool 1)
(global false bool 0)
(global CHAR_TAB u8 009) ; '\t'
(global CHAR_NWL u8 010) ; '\n'
(global CHAR_SPC u8 032) ; ' '
(global CHAR_LPAREN u8 040) (global CHAR_RPAREN u8 041)
(global CHAR_LCURLY u8 123) (global CHAR_RCURLY u8 125)
(global CHAR_LBRACK u8 091) (global CHAR_RBRACK u8 093)

(struct StringSlice
    (data ptr)
    (size u32)
)

(fn StringSlice/char_at [(self StringSlice) (index u32)] [u8] (
    (load i32/u8 {{self . data} + index})
))

; TODO: implement
(fn Parser/parse [(chars StringSlice)] [
    bool ; ok
    u32 ; index
] (
    {index : u32}
    {index = (Parser/skip_space chars 0)}

    (return false 0)
))

; TODO: add support for comments
(fn Parser/skip_space [(chars StringSlice) (index u32)] [
    u32 ; index
] (
    {res : CharAtResult}

    (loop (
        {res = (Parser/char_at chars index)}

        (if {{res . ok} != true}
            (break)
        )

        (if {(Parser/is_space {res . char}) != true}
            (break)
        )

        {index = {index + 1}}
    ))

    index
))

(fn Parser/is_valid_list_chars [(start u8) (end u8)] [bool] (
    (|| (||
    {{start == CHAR_LPAREN} && { end == CHAR_RPAREN}}
    {{start == CHAR_LCURLY} && { end == CHAR_RCURLY}})
    {{start == CHAR_LBRACK} && { end == CHAR_RBRACK}})
))

(fn Parser/is_space [(char u8)] [bool] (
    (|| (||
    {char == CHAR_SPC}
    {char == CHAR_NWL})
    {char == CHAR_TAB})
))

(struct CharAtResult (ok bool) (char u8))

;; TODO: this does not match rust version
(fn Parser/char_at [(chars StringSlice) (index u32)] [CharAtResult] (
    (if {index >= {chars . size}}
        (return (struct.new CharAtResult false 0))
    )

    (struct.new CharAtResult true (StringSlice/char_at chars index))
))

(fn Parser/index_to_position [(chars StringSlice) (index u32)] [
    u32 ; line
    u32 ; col
] (
    {line : u32}
    {col : u32}
    {(line col) = (pack 1 1)}

    {char_index : u32}
    {char_index = 0}
    (loop (
        (if {char_index >= {chars . size}} (break))
        (if {char_index >= index} (break))

        {char : u32}
        {char = (StringSlice/char_at chars char_index)}

        (if {char == CHAR_NWL} (do
            {col = 1}
            {line = {line + 1}}
            {char_index = {char_index + 1}}
            (continue)
        ))

        {col = {col + 1}}
        {char_index = {char_index + 1}}
    ))

    (pack line col)
))
