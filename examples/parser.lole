(mod lib/std)

(global Parser/SExpr/ATOM u8 0)
(global Parser/SExpr/LIST u8 1)
(struct Parser/SExpr
    (kind u8) ; Parser/SExpr/ATOM | Parser/SExpr/LIST
    (data ptr) ; pointer to Atom's chars or List's expr vector
)

(global Parser/ParseError/UNEXPECTED_EOF  u32 0)
(global Parser/ParseError/UNEXPECTED_CHAR u32 1)
(struct Parser/ParseResult
    (ok bool)
    (index u32)
    (data u32) ; Parser/ParseError/* or pointer to some result
)

(fn Parser/parse [(chars StringSlice)] [Parser/ParseResult] (
    {index : u32 = 0}

    {index = (Parser/skip_space chars index)}

    {&items : (& Vec) = (Vec/new 6 (sizeof Parser/SExpr))}

    (loop (
        (if {index >= {chars . size}} (break))

        {char_res : Parser/CharAtResult}
        {char_res = (Parser/char_at chars index)}

        (if (not {char_res . ok})
            (return (struct.new Parser/ParseResult
                false index Parser/ParseError/UNEXPECTED_EOF
            ))
        )

        (if (not (Parser/is_list_start {char_res . char}))
            (return (struct.new Parser/ParseResult
                false index Parser/ParseError/UNEXPECTED_CHAR
            ))
        )

        {res : Parser/ParseResult}
        {res = (Parser/parse_list chars index)}
        (if (not {res . ok}) (return res))

        (Vec/push_all &items {res . data} 1)

        {index = (Parser/skip_space chars {res . index})}
    ))

    (return (struct.new Parser/ParseResult true index &items))
))

(fn Parser/parse_expr [(chars StringSlice) (index u32)] [Parser/ParseResult] (
    {char_res : Parser/CharAtResult}
    {char_res = (Parser/char_at chars index)}

    (if (not {char_res . ok})
        (return (struct.new Parser/ParseResult
            false index Parser/ParseError/UNEXPECTED_EOF
        ))
    )

    (if (Parser/is_list_start {char_res . char})
        (return (Parser/parse_list chars index))
    )

    (return (Parser/parse_atom chars index))
))

(fn Parser/parse_atom [(chars StringSlice) (index u32)] [Parser/ParseResult] (
    {atom_len : u32 = 0}

    (loop (
        {char_res : Parser/CharAtResult}
        {char_res = (Parser/char_at chars index)}
        (if (not {char_res . ok}) (break))
        (if {(Parser/is_space {char_res . char})
                || (Parser/is_list_end {char_res . char})
                || {char_res . char == (char_code ";")}}
            (break)
        )
        {index = {index + 1}}
        {atom_len = {atom_len + 1}}
    ))

    ; TODO: replace 1 with (sizeof u8)
    {&atom : (& Vec) = (Vec/new atom_len 1)}
    (Vec/push_all &atom
        {chars . data + index - atom_len}
        atom_len
    )

    {&expr : (& Parser/SExpr) = (Mem/alloc (sizeof Parser/SExpr))}
    {Parser/SExpr @ &expr = (struct.new Parser/SExpr
        Parser/SExpr/ATOM
        &atom
    )}

    (return (struct.new Parser/ParseResult true index &expr))
))

(fn Parser/parse_list [(chars StringSlice) (index u32)] [Parser/ParseResult] (
    {char_res : Parser/CharAtResult}
    {char_res = (Parser/char_at chars index)}

    {list_start_char : u8 = {char_res . char}}
    {index = {index + 1}} ; eat list start

    {index = (Parser/skip_space chars index)}

    {&items : (& Vec) = (Vec/new 6 (sizeof Parser/SExpr))}

    (loop (
        {char_res = (Parser/char_at chars index)}
        (if (not {char_res . ok})
            (return (struct.new Parser/ParseResult
                false index Parser/ParseError/UNEXPECTED_EOF
            ))
        )

        (if (Parser/is_list_end {char_res . char})
            (break)
        )

        {res : Parser/ParseResult}
        {res = (Parser/parse_expr chars index)}
        (if (not {res . ok}) (return res))

        (Vec/push_all &items {res . data} 1)

        {index = (Parser/skip_space chars {res . index})}
    ))

    {char_res = (Parser/char_at chars index)}
    (if (not {char_res . ok})
        (return (struct.new Parser/ParseResult
            false index Parser/ParseError/UNEXPECTED_EOF
        ))
    )

    {list_end_char : u8 = {char_res . char}}
    {index = {index + 1}} ; eat list end

    (if (not (Parser/is_valid_list_chars list_start_char list_end_char))
        (return (struct.new Parser/ParseResult
            false index Parser/ParseError/UNEXPECTED_EOF
        ))
    )

    (if {list_start_char == (char_code "{") && {(Vec/len &items) >= 2}}
        (Vec/swap &items 0 1)
    )

    {&expr : (& Parser/SExpr) = (Mem/alloc (sizeof Parser/SExpr))}
    {Parser/SExpr @ &expr = (struct.new Parser/SExpr
        Parser/SExpr/LIST
        &items
    )}

    (return (struct.new Parser/ParseResult true index &expr))
))

(fn Parser/skip_space [(chars StringSlice) (index u32)] [u32] (
    {char_res : Parser/CharAtResult}

    (loop (
        {char_res = (Parser/char_at chars index)}
        (if (not {char_res . ok}) (break))
        (if (not (Parser/is_space {char_res . char})) (break))
        {index = {index + 1}}
    ))

    (if {char_res . ok && {char_res . char == (char_code ";")}} (do
        {index = {index + 1}}

        (loop (
            {char_res = (Parser/char_at chars index)}
            (if (not {char_res . ok}) (break))
            (if {char_res . char == (char_code "\n")} (break))
            {index = {index + 1}}
        ))

        (if {char_res . ok && {char_res . char == (char_code ";")}}
            {index = {index + 1}}
        )

        (return (Parser/skip_space chars index))
    ))

    (return index)
))

(fn Parser/is_list_start [(char u8)] [bool] (
    (return {
        {char == (char_code "(")} ||
        {char == (char_code "{")} ||
        {char == (char_code "[")}
    })
))

(fn Parser/is_list_end [(char u8)] [bool] (
    (return {
        {char == (char_code ")")} ||
        {char == (char_code "}")} ||
        {char == (char_code "]")}
    })
))

(fn Parser/is_valid_list_chars [(start u8) (end u8)] [bool] (
    (return {
        {start == (char_code "(") && {end == (char_code ")")}} ||
        {start == (char_code "{") && {end == (char_code "}")}} ||
        {start == (char_code "[") && {end == (char_code "]")}}
    })
))

(fn Parser/is_space [(char u8)] [bool] (
    (return {
        {char == (char_code " ")} ||
        {char == (char_code "\n")} ||
        {char == (char_code "\t")}
    })
))

(struct Parser/Position (line u32) (col u32))

(fn Parser/index_to_position [(chars StringSlice) (index u32)] [Parser/Position] (
    {pos : Parser/Position = (do 1 1)}

    {char_index : u32 = 0}
    (loop (
        (if {char_index >= {chars . size}} (break))
        (if {char_index >= index} (break))

        {char : u32 = (StringSlice/char_at chars char_index)}

        (if {char == (char_code "\n")} (do
            {pos = (do {pos . line + 1} 1)}
            {char_index = {char_index + 1}}
            (continue)
        ))

        {pos . col = {pos . col + 1}}

        {char_index = {char_index + 1}}
    ))

    (return pos)
))

(struct Parser/CharAtResult (ok bool) (char u8))

(fn Parser/char_at [(chars StringSlice) (index u32)] [Parser/CharAtResult] (
    (if {index >= {chars . size}}
        (return (struct.new Parser/CharAtResult false 0))
    )

    (return (struct.new Parser/CharAtResult
        true (StringSlice/char_at chars index)
    ))
))
