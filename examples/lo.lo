include "./lib/cli.lo";

include "./lib/lo/core.lo";

fn main() {
    let ctx = LoContext::new();

    // goal1(ctx);
    goal2(ctx);

    let binary = Vec::new!<u8>();
    defer binary.free();

    ctx.wasm_module.write(binary);

    print_str(binary as &str);
};

fn goal1(ctx: &LoContext) {
    let get_answer_fn_type = WasmFnType {
        inputs: Vec::new!<WasmValueType>(),
        outputs: Vec::new!<WasmValueType>(),
    };

    get_answer_fn_type.outputs.push!<WasmValueType>(WasmValueType::I32);

    ctx.wasm_module.types.push!<WasmFnType>(get_answer_fn_type);

    ctx.wasm_module.functions.push!<u32>(0);

    ctx.wasm_module.exports.push!<WasmExport>(WasmExport {
        name: String::from_str("get_answer"),
        item_type: WasmExportType::Fn,
        item_index: 0,
    });

    let expr = Vec::new!<WasmInstr>();
    expr.push!<WasmInstr>(WasmInstr::I32Const::new(42 as i32));
    expr.push!<WasmInstr>(WasmInstr::Return::new());

    ctx.wasm_module.codes.push!<WasmCode>(WasmCode {
        expr: expr,
    });
};

fn goal2(ctx: &LoContext) {
    // fd_write
        let fd_write_fn_type = WasmFnType {
            inputs: Vec::new!<WasmValueType>(),
            outputs: Vec::new!<WasmValueType>(),
        };

        fd_write_fn_type.inputs.push!<WasmValueType>(WasmValueType::I32);
        fd_write_fn_type.inputs.push!<WasmValueType>(WasmValueType::I32);
        fd_write_fn_type.inputs.push!<WasmValueType>(WasmValueType::I32);
        fd_write_fn_type.inputs.push!<WasmValueType>(WasmValueType::I32);

        fd_write_fn_type.outputs.push!<WasmValueType>(WasmValueType::I32);

        ctx.wasm_module.types.push!<WasmFnType>(fd_write_fn_type);

        let fd_write_import = WasmImport {
            module_name: String::from_str("wasi_snapshot_preview1"),
            item_name: String::from_str("fd_write"),
            item_type: WasmImportType::Fn,
            item_index: 0, // index of fd_write_fn_type
        };

        ctx.wasm_module.imports.push!<WasmImport>(fd_write_import);

    // _start
        let _start_fn_type = WasmFnType {
            inputs: Vec::new!<WasmValueType>(),
            outputs: Vec::new!<WasmValueType>(),
        };

        ctx.wasm_module.types.push!<WasmFnType>(_start_fn_type);

        // body
            let expr = Vec::new!<WasmInstr>();
            expr.push!<WasmInstr>(WasmInstr::Return::new());

            // TODO:
            // (local i32 i32)
            // i32.const 12
            // local.set 0
            // i32.const 4
            // local.get 0
            // i32.store align=1
            // i32.const 13
            // local.set 1
            // i32.const 8
            // local.get 1
            // i32.store align=1
            // i32.const 1
            // i32.const 4
            // i32.const 1
            // i32.const 0
            // call 0
            // drop

            ctx.wasm_module.codes.push!<WasmCode>(WasmCode {
                expr: expr,
            });

        ctx.wasm_module.functions.push!<u32>(1);

        ctx.wasm_module.exports.push!<WasmExport>(WasmExport {
            name: String::from_str("_start"),
            item_type: WasmExportType::Fn,
            item_index: 0, // index of _start function
        });

    // TODO:
    // (memory (;0;) 1)
    // (export "memory" (memory 0))
    // (data (;0;) (i32.const 12) "Hello World!\0a")
};
