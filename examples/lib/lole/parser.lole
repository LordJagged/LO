(mod lib/std)
(mod lib/lole/ast)

(struct Lole/Parser
    (file_name StringSlice)
    (chars StringSlice)
    (index u32)
    (line u32)
    (col u32)
)

(struct Lole/Parser/ParseResult
    (ok bool)
    (data (& void)) ; (& Lole/Ast/SExpr) | (& Lole/Ast/CompileError)
)

(struct Lole/Parser/ParseScriptResult
    (ok bool)
    (data (& void)) ; (& Vec<Lole/Ast/SExpr>) | (& Lole/Ast/CompileError)
)

; public interface
(fn Lole/Parser/parse [(file_name StringSlice) (script StringSlice)] Lole/Parser/ParseScriptResult (
    {parser := (new Lole/Parser (Lole/Parser/new file_name script)
        :using Alloc/STACK)}
    (defer (free Alloc/STACK parser (sizeof Lole/Parser)))

    (return (Lole/Parser/parse_all parser))
))

(fn Lole/Parser/new [(file_name StringSlice) (script StringSlice)] Lole/Parser (
    (return (Lole/Parser
        :file_name file_name
        :chars script
        :index 0
        :line 1
        :col 1
    ))
))

(fn Lole/Parser/parse_all [(self (& Lole/Parser))] Lole/Parser/ParseScriptResult (
    (Lole/Parser/skip_space self)

    {items := (Vec/new 10 (sizeof Lole/Ast/SExpr))}

    (loop (
        ; TODO: support chaining `->`
        (if {self -> index >= {self -> chars . size}} (
            (break)
        ))

        {res := (Lole/Parser/current_char self)}
        (if (not {res . ok}) (
            (return res)
        ))

        (if (not (Lole/Parser/is_list_start {res . data})) (
            (return (Lole/Parser/ParseScriptResult
                :ok false
                :data {(Lole/Parser/err_unexpected_char self) as (& void)}
            ))
        ))

        {expr_res := (Lole/Parser/parse_list self)}
        (if (not {expr_res . ok}) (
            (return expr_res)
        ))

        (Lole/Parser/skip_space self)

        (Vec/push_all items {expr_res . data} 1)
    ))

    (return (Lole/Parser/ParseScriptResult
        :ok true
        :data {items as (& void)}
    ))
))

(fn Lole/Parser/parse_expr [(self (& Lole/Parser))] Lole/Parser/ParseResult (
    {res := (Lole/Parser/current_char self)}
    (if (not {res . ok}) (
        (return res)
    ))

    (if (Lole/Parser/is_list_start {res . data}) (
        (return (Lole/Parser/parse_list self))
    ))

    (return (Lole/Parser/parse_atom self))
))

(fn Lole/Parser/parse_atom [(self (& Lole/Parser))] Lole/Parser/ParseResult (
    {res := (Lole/Parser/current_char self)}
    (if (not {res . ok}) (
        (return res)
    ))

    (if {res . data == (char_code "\"")} (
        (return (Lole/Parser/parse_string self))
    ))

    (return (Lole/Parser/parse_symbol self))
))

(fn Lole/Parser/parse_string [(self (& Lole/Parser))] Lole/Parser/ParseResult (
    {loc := (Lole/Parser/loc self)}

    (Lole/Parser/next_char self) ; skip start quote

    {value := (String/new 6)}

    (loop (
        {res := (Lole/Parser/current_char self)}
        (if (not {res . ok}) (
            (return res)
        ))

        (if {res . data == (char_code "\"")} (
            (break)
        ))

        (if {res . data != (char_code "\\")} (
            (Vec/push_u8 value {res . data})
            (Lole/Parser/next_char self)
            (continue)
        ))
        (Lole/Parser/next_char self) ; skip '\'

        {res = (Lole/Parser/current_char self)}
        (if (not {res . ok}) (
            (return res)
        ))

        (if {res . data == (char_code "n")} (
            (Vec/push_u8 value (char_code "\n"))
            (Lole/Parser/next_char self)
            (continue)
        ))

        (if {res . data == (char_code "t")} (
            (Vec/push_u8 value (char_code "\t"))
            (Lole/Parser/next_char self)
            (continue)
        ))

        (if {res . data == (char_code "\\")
                || {res . data == (char_code "\"")}} (
            (Vec/push_u8 value {res . data})
            (Lole/Parser/next_char self)
            (continue)
        ))

        (return (Lole/Parser/ParseResult
            :ok false
            :data {(Lole/Parser/err_unexpected_char self) as (& void)}
        ))
    ))

    (Lole/Parser/next_char self) ; skip end quote

    {loc . item_size = {self -> index - {loc . offset}}}

    (return (Lole/Parser/ParseResult
        :ok true
        :data {(new Lole/Ast/SExpr (Lole/Ast/SExpr
            :kind Lole/Ast/SExpr/ATOM
            :value {(new Lole/Ast/SExpr/Atom (Lole/Ast/SExpr/Atom
                :value value
                :kind Lole/Ast/AtomKind/STRING
                :loc loc
            )) as (& void)}
        )) as (& void)}
    ))
))

(fn Lole/Parser/parse_symbol [(self (& Lole/Parser))] Lole/Parser/ParseResult (
    {loc := (Lole/Parser/loc self)}

    (loop (
        {res := (Lole/Parser/current_char self)}
        (if {(Lole/Parser/is_space {res . data})
                || (Lole/Parser/is_list_end {res . data})
                || {res . data == (char_code ";")}} (
            (break)
        ))
        (Lole/Parser/next_char self)
    ))

    {loc . item_size = {self -> index - {loc . offset}}}

    {value := (String/from_slice
        {self -> chars . data + {loc . offset}} {loc . item_size}) }

    (return (Lole/Parser/ParseResult
        :ok true
        :data {(new Lole/Ast/SExpr (Lole/Ast/SExpr
            :kind Lole/Ast/SExpr/ATOM
            :value {(new Lole/Ast/SExpr/Atom (Lole/Ast/SExpr/Atom
                :value value
                :kind Lole/Ast/AtomKind/SYMBOL
                :loc loc
            )) as (& void)}
        )) as (& void)}
    ))
))

(fn Lole/Parser/parse_list [(self (& Lole/Parser))] Lole/Parser/ParseResult (
    {loc := (Lole/Parser/loc self)}

    {res := (Lole/Parser/current_char self)}
    (if (not {res . ok}) (
        (return res)
    ))
    {list_start_char := {res . data}}
    (Lole/Parser/next_char self) ; eat list start

    (Lole/Parser/skip_space self)

    {items := (Vec/new 6 (sizeof Lole/Ast/SExpr))}

    (loop (
        {res = (Lole/Parser/current_char self)}
        (if (not {res . ok}) (
            (return res)
        ))

        (if (Lole/Parser/is_list_end {res . data}) (
            (break)
        ))

        {expr_res := (Lole/Parser/parse_expr self)}
        (if (not {expr_res . ok}) (
            (return expr_res)
        ))
        (Vec/push_all items {expr_res . data} 1)

        (Lole/Parser/skip_space self)
    ))

    {res = (Lole/Parser/current_char self)}
    (if (not {res . ok}) (
        (return res)
    ))
    {list_end_char := {res . data}}
    (Lole/Parser/next_char self) ; eat list end

    {loc . item_size = {self -> index - {loc . offset}}}

    (if {list_start_char == (char_code "{") && {items -> size >= 2}} (
        (return (Lole/Parser/m_expr_to_s_expr_and_validate items loc))
    ))

    (return (Lole/Parser/ParseResult
        :ok true
        :data {(new Lole/Ast/SExpr (Lole/Ast/SExpr
            :kind Lole/Ast/SExpr/LIST
            :value {(new Lole/Ast/SExpr/List (Lole/Ast/SExpr/List
                :value items
                :loc loc
            )) as (& void)}
        )) as (& void)}
    ))
))

(fn Lole/Parser/skip_space [(self (& Lole/Parser))] void (
    {res : Lole/Parser/CharAtResult}

    (loop (
        {res = (Lole/Parser/current_char self)}
        (if (not {res . ok}) (
            (return)
        ))
        (if (not (Lole/Parser/is_space {res . data})) (
            (break)
        ))

        (Lole/Parser/next_char self)
    ))

    (if {res . data != (char_code ";")} (
        (return)
    ))
    (Lole/Parser/next_char self)

    (loop (
        {res = (Lole/Parser/current_char self)}
        (if (not {res . ok}) (
            (return)
        ))
        (if {res . data == (char_code "\n")} (
            (break)
        ))
        (Lole/Parser/next_char self)
    ))

    (if {res . data == (char_code ";")} (
        (Lole/Parser/next_char self)
    ))

    (Lole/Parser/skip_space self)
))

(fn Lole/Parser/next_char [(self (& Lole/Parser))] void (
    {self -> index += 1}

    {res := (Lole/Parser/current_char self)}
    (if (not {res . ok}) (
        (return)
    ))

    (if {res . data == (char_code "\n")} (
        {self -> col = 0}
        {self -> line += 1}
        (return)
    ))

    {self -> col += 1}
))

(struct Lole/Parser/CharAtResult
    (ok bool)
    (data (& void)) ; u8 | (& CompileError)
)

(fn Lole/Parser/current_char [(self (& Lole/Parser))] Lole/Parser/CharAtResult (
    {chars := {self -> chars}}

    (if {self -> index >= {chars . size}} (
        (return (Lole/Parser/CharAtResult
            :ok false
            :data {(Lole/Parser/err_unexpected_eof self) as (& void)}
        ))
    ))

    (return (Lole/Parser/CharAtResult
        :ok true
        :data {(StringSlice/char_at chars {self -> index}) as (& void)}
    ))
))

(fn Lole/Parser/err_unexpected_char [(self (& Lole/Parser))] (& Lole/Ast/CompileError) (
    (return (new Lole/Ast/CompileError (Lole/Ast/CompileError
        :message (String/from_slice "ParseError: Unexpected character")
        :loc (Lole/Parser/loc self)
    )))
))

(fn Lole/Parser/err_unexpected_eof [(self (& Lole/Parser))] (& Lole/Ast/CompileError) (
    (return (new Lole/Ast/CompileError (Lole/Ast/CompileError
        :message (String/from_slice "ParseError: Unexpected EOF")
        :loc (Lole/Parser/loc self)
    )))
))

(fn Lole/Parser/loc [(self (& Lole/Parser))] Lole/Ast/Location (
    (return (Lole/Ast/Location
        :file_name (StringSlice/clone {self -> file_name})
        :offset {self -> index}
        :item_size 1
        :line {self -> line}
        :col {self -> col}
    ))
))

(fn Lole/Parser/m_expr_to_s_expr_and_validate [(items (& Vec<Lole/Ast/SExpr>)) (loc Lole/Ast/Location)] Lole/Parser/ParseResult (
    (if {items -> size % 2 != 1} (
        (return (Lole/Parser/ParseResult
            :ok false
            :data {(new Lole/Ast/CompileError (Lole/Ast/CompileError
                :message (String/from_slice "ParseError: Invalid m-expr: even item_size")
                :loc loc
            )) as (& void)}
        ))
    ))

    (if {items -> size < 2} (
        (return (Lole/Parser/ParseResult
            :ok true
            :data {(new Lole/Ast/SExpr (Lole/Ast/SExpr
                :kind Lole/Ast/SExpr/LIST
                :value {(new Lole/Ast/SExpr/List (Lole/Ast/SExpr/List
                    :value items
                    :loc loc
                )) as (& void)}
            )) as (& void)}
        ))
    ))

    (return (Lole/Parser/ParseResult
        :ok true
        :data {(new Lole/Ast/SExpr
            (Lole/Parser/m_expr_to_s_expr items loc)
        ) as (& void)}
    ))
))

; ❓ {1 + 2 - 3 * 4}
; 🚫 (+ 1 (- 2 (* 3 4)))
; ✅ (* (- (+ 1 2) 3) 4)
(fn Lole/Parser/m_expr_to_s_expr [(items (& Vec<Lole/Ast/SExpr>)) (loc Lole/Ast/Location)] Lole/Ast/SExpr (
    (if {items -> size == 1} (
        (defer (Vec/free items))
        (return {Lole/Ast/SExpr @ (Vec/at items 0)})
    ))

    {rhs := {Lole/Ast/SExpr @ (Vec/pop_unchecked items)}}
    {op := {Lole/Ast/SExpr @ (Vec/pop_unchecked items)}}
    {lhs := (Lole/Parser/m_expr_to_s_expr items (Lole/Ast/Location/clone loc))}

    {sexpr_items := (Vec/new 3 (sizeof Lole/Ast/SExpr))}
    {Lole/Ast/SExpr @ (Vec/push_undef sexpr_items) = op}
    {Lole/Ast/SExpr @ (Vec/push_undef sexpr_items) = lhs}
    {Lole/Ast/SExpr @ (Vec/push_undef sexpr_items) = rhs}

    (return (Lole/Ast/SExpr
        :kind Lole/Ast/SExpr/LIST
        :value {(new Lole/Ast/SExpr/List (Lole/Ast/SExpr/List
            :value sexpr_items
            :loc loc
        )) as (& void)}
    ))
))

(fn Lole/Parser/is_list_start [(char u8)] bool (
    (return {
        {char == (char_code "(")} ||
        {char == (char_code "{")} ||
        {char == (char_code "[")}
    })
))

(fn Lole/Parser/is_list_end [(char u8)] bool (
    (return {
        {char == (char_code ")")} ||
        {char == (char_code "}")} ||
        {char == (char_code "]")}
    })
))

(fn Lole/Parser/is_valid_list_chars [(start u8) (end u8)] bool (
    (return {
        {start == (char_code "(") && {end == (char_code ")")}} ||
        {start == (char_code "{") && {end == (char_code "}")}} ||
        {start == (char_code "[") && {end == (char_code "]")}}
    })
))

(fn Lole/Parser/is_space [(char u8)] bool (
    (return {
        {char == (char_code " ")} ||
        {char == (char_code "\n")} ||
        {char == (char_code "\t")}
    })
))
