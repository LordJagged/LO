(mod lib/std)
(mod lib/lole/ir)
(mod lib/lole/parser)

(struct Lole/Compiler/CompileResult
    (ok bool)
    (data (& void)) ; 0 | (& Lole/Ast/CompileError)
)

(fn Lole/Compiler/compile [
    (&exprs (& Vec<Lole/Ast/SExpr>)) (&wasm_module (& Lole/Wasm/WasmModule))
] [Lole/Compiler/CompileResult] (
    {&ctx : (& Lole/Ir/ModuleContext) = (Lole/Ir/ModuleContext/new &wasm_module)}
    (defer (Lole/Ir/ModuleContext/free &ctx))

    {i := 0}
    (loop (
        (if {i == (Vec/len &exprs)} (break))

        {res : Lole/Compiler/CompileResult =
            (Lole/Compiler/compile_top_level_expr
                {Lole/Ast/SExpr @ (Vec/at &exprs i)}
                &ctx
            )
        }
        (if (not {res . ok}) (return res))

        {i += 1}
    ))

    {&fn_defs : (& Dict<Lole/Ir/FnDef>) = {&ctx -> &fn_defs}}
    {&fn_exports : (& Vec<String>) = {&ctx -> &fn_exports}}

    ; push function exports
    {i = 0}
    (loop (
        (if {i == (Vec/len &fn_exports)} (break))

        {fn_export : Lole/Ir/FnExport = {Lole/Ir/FnExport @ (Vec/at &fn_exports i)}}

        {fn_def_res : Dict/GetResult = (Dict/get &fn_defs (Vec/as_slice {fn_export . &in_name}))}
        (if (not {fn_def_res . ok}) (do
            {&msg : (& String) = (String/from_slice "Cannot export unknown function: ")}
            (Vec/push_all &msg (Vec/as_slice {fn_export . &in_name}))

            (return false (new Lole/Ast/CompileError (do
                &msg
                (Lole/Ast/Location/clone {fn_export . loc})
            )))
        ))
        {fn_def : Lole/Ir/FnDef = {Lole/Ir/FnDef @ {fn_def_res . &value}}}

        {&exports : (& Vec) = {&wasm_module -> &exports}}

        {Lole/Wasm/WasmExport @ (Vec/push_undef &exports) = (struct.new Lole/Wasm/WasmExport
            Lole/Wasm/WasmExportType/FUNC
            (String/clone {fn_export . &out_name})
            {&ctx -> imported_fns_count + {fn_def . fn_index}}
        )}

        {i += 1}
    ))

    {&fn_bodies : (& Dict<Lole/Ir/FnDef>) = {&ctx -> &fn_bodies}}
    {&fn_types : (& Vec<Lole/Wasm/WasmFnType>) = {&wasm_module -> &types}}

    ; push function codes
    {i = 0}
    (loop (
        (if {i == (Vec/len &fn_bodies)} (break))

        {fn_body : Lole/Ir/FnBody = {Lole/Ir/FnBody @ (Vec/at &fn_bodies i)}}

        {&fn_type : (& Lole/Wasm/WasmFnType) = (Vec/at &fn_types {fn_body . type_index})}

        {&fn_ctx : (& Lole/Ir/FnContext) = (new Lole/Ir/FnContext (do
            &ctx
            &fn_type
            {fn_body . &locals}
            {fn_body . locals_last_index}
            (Vec/new 1 (sizeof Lole/Wasm/WasmType))
            (Dict/new 1 (sizeof Lole/Ast/SExpr))
        ))}

        {instrs_res : Lole/Compiler/CompileBlockResult = (Lole/Compiler/compile_block
            {fn_body . &body} &fn_ctx
        )}
        (if (not {instrs_res . ok}) (return instrs_res))
        {&instrs : (& Vec<Lole/Wasm/WasmInstr>) = {instrs_res . data}}

        {deferred_res : Lole/Compiler/GetDefferedRes = (Lole/Compiler/get_deferred
            "return" ; TODO: this should be a constant
            &fn_ctx
        )}
        (if {deferred_res . ok} (do
            (Vec/append &instrs {deferred_res . data})
            (Vec/free {deferred_res . data})
        ))

        {&locals : (& Vec<Lole/Wasm/WasmLocals>) = (Vec/new 1 (sizeof Lole/Wasm/WasmLocals))}
        {&non_arg_locals : (& Vec<Lole/Wasm/WasmType>) = {&fn_ctx -> &non_arg_locals}}

        {j := 0}
        (loop (
            (if {j == (Vec/len &non_arg_locals)} (break))

            {local_type : Lole/Wasm/WasmType = {Lole/Wasm/WasmType @ (Vec/at &non_arg_locals j)}}
            {locals_len : u32 = (Vec/len &locals)}
            (if {locals_len > 0} (do
                {&wasm_locals : (& Lole/Wasm/WasmLocals) = (Vec/at &locals {locals_len - 1})}
                (if {&wasm_locals -> value_type == local_type} (do
                    {&wasm_locals -> count += 1}
                    (continue)
                ))
            ))

            {Lole/Wasm/WasmLocals @ (Vec/push_undef &locals) = (struct.new Lole/Wasm/WasmLocals
                1
                local_type
            )}

            {j += 1}
        ))

        {&codes : (& Vec<Lole/Wasm/WasmFn>) = {&wasm_module -> &codes}}
        {Lole/Wasm/WasmFn @ (Vec/push_undef &codes) = (struct.new Lole/Wasm/WasmFn
            &locals
            (struct.new Lole/Wasm/WasmExpr &instrs)
        )}

        {i += 1}
    ))

    (return true 0)
))

; TODO: implement
(fn Lole/Compiler/compile_top_level_expr [
    (expr Lole/Ast/SExpr) (&ctx (& Lole/Ir/ModuleContext))
] [Lole/Compiler/CompileResult] (
    (if {expr . kind == Lole/Ast/SExpr/ATOM} (do
        (return false (new Lole/Ast/CompileError (do
            (String/from_slice "Unexpected atom")
            (Lole/Ast/Location/clone (Lole/Ast/SExpr/loc expr))
        )))
    ))

    (return true 0)
))

(struct Lole/Compiler/CompileBlockResult
    (ok bool)
    (data (& void)) ; (& Vec<Lole/Wasm/WasmInstr>) | (& Lole/Ast/CompileError)
)

; TODO: implement
(fn Lole/Compiler/compile_block [
    (&exprs (& Vec<Lole/Ast/SExpr>)) (&ctx (& Lole/Ir/ModuleContext))
] [Lole/Compiler/CompileBlockResult] (
    (return true 0)
))

(struct Lole/Compiler/GetDefferedRes
    (ok bool)
    (data (& void)) ; (& Vec<Lole/Wasm/WasmInstr>) | (& Lole/Ast/CompileError)
)

; TODO: implement
(fn Lole/Compiler/get_deferred [
    (defer_label StringSlice) (&ctx (& Lole/Ir/ModuleContext))
] [Lole/Compiler/GetDefferedRes] (
    (return true 0)
))
