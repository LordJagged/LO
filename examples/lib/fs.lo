include "lib/std";

struct fs {};

// fs expects host to preopen "." on fd 3
const fs::CWD_PREOPEN_FD = 3;

// TODO: return errors instead of exiting with logs
fn fs::read_file(file_name: str) -> &String {
    let open_res = fs::open(file_name);
    if open_res.err != 0 {
        fputs(wasi::FD_STDERR, "Error opening file: ");
        fputs(wasi::FD_STDERR, file_name);
        fputs(wasi::FD_STDERR, "\n");
        wasi::proc_exit(1);
    };
    let fd = open_res.fd;

    return fs::read_fd(fd);
};

struct fs::FdOpenRes {
    err: wasi::Err,
    fd: u32,
};

fn fs::open(file_path: str) -> fs::FdOpenRes {
    let fd_ref = alloc!<u32>(alloc::STACK);
    defer free!<u32>(alloc::STACK, fd_ref);

    let err = wasi::path_open(
        fs::CWD_PREOPEN_FD, 0,
        file_path.data, file_path.size, 0, 2u64, 0u64, 0,
        fd_ref,
    );

    return fs::FdOpenRes { err: err, fd: *fd_ref };
};

fn fs::read_fd(fd: u32) -> &String {
    let output = Vec::with_capacity!<u8>(256);

    // TODO(bug): alloc::STACK is messing stuff up for some reason
    let chunk = alloc_many!<u8>(alloc::HEAP, 256);
    defer free_many!<u8>(alloc::HEAP, chunk, 256);

    let in_vec = alloc!<wasi::IOVec>(alloc::STACK);
    defer free!<wasi::IOVec>(alloc::STACK, in_vec);
    *in_vec = wasi::IOVec { base: chunk, size: 256 };

    let nread_ref = alloc!<u32>(alloc::STACK);
    defer free!<u32>(alloc::STACK, nread_ref);

    loop {
        let _err = wasi::fd_read(fd, in_vec, 1, nread_ref);

        let nread = *nread_ref;
        if nread == 0 {
            break;
        };

        output.push_all(chunk as &(), nread);
    };

    return output;
};


fn fs::pipe(fd_in: u32, fd_out: u32, chunk_size: u32) -> bool {
    let chunk = alloc_many!<u8>(alloc::STACK, chunk_size);
    defer free_many!<u8>(alloc::STACK, chunk, chunk_size);

    let iov = alloc!<wasi::IOVec>(alloc::STACK);
    defer free!<wasi::IOVec>(alloc::STACK, iov);
    *iov = wasi::IOVec { base: chunk, size: 0 };

    let nread_ref = alloc!<u32>(alloc::STACK);
    defer free!<u32>(alloc::STACK, nread_ref);

    loop {
        iov.size = chunk_size;
        let io_res = wasi::fd_read(fd_in, iov, 1, nread_ref);
        if io_res != 0 {
            return false;
        };

        let nread = *nread_ref;
        if nread == 0 {
            break;
        };

        iov.size = nread;
        io_res = wasi::fd_write(fd_out, iov, 1, nread_ref);
        if io_res != 0 {
            return false;
        };
    };

    return true;
};

fn fs::close(fd: u32) {
    let _ = wasi::fd_close(fd); // TODO: ignore close error?
};
