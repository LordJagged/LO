(mem m1 :min 1000)

(export parse :as parse)

;; exporting for testing
(export mem m1 :as memory)
(export skip_space :as skip_space)
(export char_at :as char_at)
(export index_to_position :as index_to_position)

(struct StringSlice
    (data i32)
    (size i32)
)

(fn StringSlice/char_at [(self StringSlice) (index i32)] [i32] (
    (i32.load8_u {{self . data} + index})
))

; TODO: implement
(fn parse [(chars StringSlice)] [
    i32 ; ok
    i32 ; index
] (
    {index : i32}
    {index = (skip_space chars 0)}

    (return 0 0)
))

; TODO: add support for comments
(fn skip_space [(chars StringSlice) (index i32)] [
    i32 ; index
] (
    {res : CharAtResult}

    (loop (
        {res = (char_at chars index)}

        (if {{res . ok} != 1}
            (break)
        )

        (if {{res . char} != 32} ; space
            (break)
        )

        {index = {index + 1}}
    ))

    index
))

(struct CharAtResult
    (ok i32)
    (char i32)
)

;; TODO: should match be added?
;; (fn is_space [(c i32)] [i32] (
;;     (match c
;;         ({' ' | '\n' | '\t'} true)
;;         (else 0)
;;     )
;; ))

(fn char_at [(chars StringSlice) (index i32)] [CharAtResult] (
    (if {index >= {chars . size}}
        (return (struct.new CharAtResult 0 0))
    )

    (struct.new CharAtResult 1 (StringSlice/char_at chars index))
))

(fn index_to_position [(chars StringSlice) (index i32)] [i32 i32] (
    {line : i32}
    {col : i32}
    {(line col) = (pack 1 1)}

    {char_index : i32}
    {char_index = 0}
    (loop (
        (if {char_index >= {chars . size}} (break))
        (if {char_index >= index} (break))

        {char : i32}
        {char = (StringSlice/char_at chars char_index)}

        (if {char == 10} (do ;; '\n'
            {col = 1}
            {line = {line + 1}}
            {char_index = {char_index + 1}}
            (continue)
        ))

        {col = {col + 1}}
        {char_index = {char_index + 1}}
    ))

    (pack line col)
))
