(global true bool 1)
(global false bool 0)

; unrecoverable-errors

    (global Unrec/UNKNOWN u32 0)
    (global Unrec/STACK_OVERFLOW u32 1)
    (global Unrec/STACK_UNDERFLOW u32 2)
    (global mut Unrec/ERR u32 0)

; alloc

    (global Alloc/STACK u32 0)
    (global Alloc/HEAP u32 1)

    (fn alloc [(alloc_id u32) (size u32)] [ptr] (
        (if {alloc_id == 0} (return (Stack/alloc size)))
        (return (Mem/alloc size))
    ))

    (fn free [(alloc_id u32) (ptr u32) (size u32)] [] (
        (if {alloc_id == 0} (return (Stack/free size)))
        (return (Mem/free ptr))
    ))

; stack

    (global mut Stack/&CURRENT u32 (data.size))
    (global mut Stack/&BEGIN ptr (data.size))
    (global mut Stack/&END u32 1048576)

    (fn Stack/push_u32 [(value u32)] [] (
        {i32 @ (Stack/alloc (sizeof u32)) = value}
    ))

    (fn Stack/read_u32 [] [u32] (
        (return {i32 @ {Stack/&CURRENT - (sizeof u32)}})
    ))

    (fn Stack/pop_u32 [] [u32] (
        (Stack/free (sizeof u32))

        (return {i32 @ Stack/&CURRENT})
    ))

    (fn Stack/alloc [(size u32)] [ptr] (
        {Stack/&CURRENT = {Stack/&CURRENT + size}}

        (if {Stack/&CURRENT > Stack/&END} (do
            {Unrec/ERR = Unrec/STACK_OVERFLOW}
            (unreachable)
        ))

        (return {Stack/&CURRENT - size})
    ))

    (fn Stack/free [(size u32)] [] (
        {Stack/&CURRENT = {Stack/&CURRENT - size}}

        (if {Stack/&CURRENT < Stack/&BEGIN} (do
            {Unrec/ERR = Unrec/STACK_UNDERFLOW}
            (unreachable)
        ))
    ))

; mem

    (global mut Mem/&CURRENT u32 1048576) ; starts after stack end
    (fn Mem/alloc [(size u32)] [ptr] (
        {ref : ptr = Mem/&CURRENT}
        {Mem/&CURRENT = {Mem/&CURRENT + size}}
        (return ref)
    ))

    ; TODO: implement
    (fn Mem/free [(ref ptr)] [] ())

    ; TODO: use builtin mem.copy instr
    (fn Mem/copy [(src ptr) (dist ptr) (size u32)] [] (
        (loop (
            (if {size == 0} (break))
            {size = {size - 1}}

            {i32/u8 @ dist @ size = {i32/u8 @ src @ size}}
        ))
    ))

    (fn Mem/swap [(ref1 ptr) (ref2 ptr) (size u32)] [] (
        (loop (
            (if {size == 0} (break))
            {size = {size - 1}}

            {
            (do {i32/u8 @ ref1 @ size}
                {i32/u8 @ ref2 @ size})
                =
            (do {i32/u8 @ ref2 @ size}
                {i32/u8 @ ref1 @ size})
            }
        ))
    ))

; vec

    (struct Vec
        (&data ptr)
        (length u32)
        (capacity u32)
        (item_size u32)
    )

    (fn Vec/new [(capacity u32) (item_size u32)] [(& Vec)] (
        (return (new Vec (do
            (alloc Alloc/HEAP {capacity * item_size})
            0
            capacity
            item_size
        ) :using Alloc/HEAP))
    ))

    ; TODO: check out of bounds
    (fn Vec/get_u8 [(&self (& Vec)) (index u32)] [u8] (
        (return {i32/u8
            @ {Vec @ &self . &data}
            @ {index * {Vec @ &self . item_size}}})
    ))

    ; TODO: check out of bounds
    (fn Vec/swap [(&self (& Vec)) (index1 u32) (index2 u32)] [] (
        {item_size : u32 = {Vec @ &self . item_size}}
        (Mem/swap
            {Vec @ &self . &data + {index1 * item_size}}
            {Vec @ &self . &data + {index2 * item_size}}
            item_size
        )
    ))

    (fn Vec/len [(&self (& Vec))] [u32] (
        (return {Vec @ &self . length})
    ))

    (fn Vec/push_u8 [(&self (& Vec)) (item u8)] [] (
        {index : u32 = {Vec @ &self . length}}
        {Vec @ &self . length = {index + 1}}

        (Vec/grow_if_needed &self)

        {i32/u8
            @ {Vec @ &self . &data }
            @ {index * {Vec @ &self . item_size}} = item}
    ))

    (fn Vec/push_all [(&self (& Vec)) (&items ptr) (items_len u32)] [] (
        {old_len : u32 = {Vec @ &self . length}}
        {Vec @ &self . length = {old_len + items_len}}

        (Vec/grow_if_needed &self)

        (Mem/copy
            &items
            {Vec @ &self . &data + {old_len * {Vec @ &self . item_size}}}
            {items_len * {Vec @ &self . item_size}}
        )
    ))

    (fn Vec/push_undef [(&self (& Vec))] [ptr] (
        {Vec @ &self . length = {Vec @ &self . length + 1}}

        (Vec/grow_if_needed &self)

        (return (Vec/at &self {Vec @ &self . length - 1}))
    ))

    (fn Vec/pop_unchecked [(&self (& Vec))] [ptr] (
        {Vec @ &self . length = {Vec @ &self . length - 1}}
        (return (Vec/at &self (Vec/len &self)))
    ))

    (fn Vec/grow_if_needed [(&self (& Vec))] [] (
        (if {Vec @ &self . length != {Vec @ &self . capacity}} (do
            (return)
        ))

        {item_size : u32 = {Vec @ &self . item_size}}
        {&old_data : ptr = {Vec @ &self . &data}}
        {old_capacity : u32 = {Vec @ &self . capacity}}

        {Vec @ &self . capacity = {old_capacity * 2}}
        {Vec @ &self . &data = (alloc Alloc/HEAP {Vec @ &self . capacity * item_size})}

        (Mem/copy &old_data {Vec @ &self . &data} {Vec @ &self . length * item_size})
        (free Alloc/HEAP &old_data old_capacity)
    ))

    (fn Vec/reverse [(&self (& Vec))] [] (
        {start : u32 = 0}
        {end : u32 = {(Vec/len &self) - 1}}

        (loop (
            (if {start >= end} (break))

            (Vec/swap &self start end)
            {start = {start + 1}}
            {end = {end - 1}}
        ))
    ))

    (fn Vec/as_slice [(&self (& Vec))] [ptr u32] (
        (return {Vec @ &self . &data} {Vec @ &self . length})
    ))

    (fn Vec/at [(&self (& Vec)) (index u32)] [u32] (
        (return {Vec @ &self . &data + {index * {Vec @ &self . item_size}}})
    ))

; string

    (struct String (actual ptr)) ; actually an alias for Vec<u8>
    (struct StringSlice (data (&* u8)) (size u32))

    (fn StringSlice/char_at [(self StringSlice) (index u32)] [u8] (
        (return {i32/u8 @ {self . data} @ index})
    ))

    (fn String/from_slice [(str StringSlice)] [(& String)] (
        {&string : (& String) = (Vec/new {str . size} 1)}
        (Vec/push_all &string str)
        (return &string)
    ))

; conversions

    ; ascii digits: 48-57
    (fn std/u32_to_string [(input u32)] [(& String)] (
        {&output : (& String) = (Vec/new 32 1)}

        (if {input == 0} (do
            (Vec/push_u8 &output (char_code "0"))
            (return &output)
        ))

        (loop (
            {rem : u32 = {input % 10}}

            (Vec/push_u8 &output {(char_code "0") + rem})
            {input = {input / 10}}

            (if {input == 0} (break))
        ))

        (Vec/reverse &output)

        (return &output)
    ))
