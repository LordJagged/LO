; current

(struct Point2D
    (x u32)
    (y u32)
)

(fn main [] u32 (
    {&p : (& Point2D) = (Stack/alloc (sizeof Point2D))}
    (defer (Stack/free (sizeof Point2D)))

    {(* &p) = (Point2D :x 2 :y 3)}
    {y := {&p -> y}}
    (return y)
))

; v2?

(struct Point2D
    (x u32)
    (y u32)
)

(fn main [] u32 (
    {p := (stack.new (Point2D :x 2 :y 3))}
    (defer (stack.free p))

    {y := {p . y}}
    (return y)
))

; v3?

{Point2D :: (struct
    :x u32
    :y u32
)}

{main :: (fn [] u32 (
    {p := (stack.new (Point2D :x 2 :y 3))}
    (defer (stack.free p))

    {y := {p . y}}
    (return y)
))}

; v4?

Point2D :: struct {
    x: u32
    y: u32
}

main :: fn() -> u32 {
    p := stack.new(Point2D { x: 2, y: 3 });
    defer stack.free(p);

    y := p.y;
    return y;
}
