include "./core.lo";
include "./ir.lo";
include "./lexer.lo";

struct LoParser {
    ctx: &LoContext,
    tokens: &LoTokenStream,
};

fn LoParser::parse_all(self): void throws &LoError {
    loop {
        let some_token = self.tokens.peek();
        if !some_token.exists {
            break;
        };

        self.parse_top_level_expr()?;

        let _ = self.tokens.expect(LoTokenType::Delim, ";")?;
    };

    let some_token = self.tokens.peek();
    if some_token.exists {
        let message = String::from_str("Unexpected token on top level: ");
        String::append_str(message, some_token.token.repr);

        throw heap::new!<LoError>(LoError {
            message: message,
            loc: some_token.token.loc,
        });
    };
};

fn LoParser::parse_top_level_expr(self): void throws &LoError {
    let some_token = self.tokens.peek();
    if !some_token.exists {
        return;
    };

    some_token = self.tokens.eat(LoTokenType::Symbol, "fn")?;
    if some_token.exists {
        return self.parse_fn_def(false)?;
    };

    some_token = self.tokens.eat(LoTokenType::Symbol, "export")?;
    if some_token.exists {
        some_token = self.tokens.eat(LoTokenType::Symbol, "fn")?;
        if some_token.exists {
            return self.parse_fn_def(true)?;
        };

        // TODO: parse other exportables
    };

    // TODO: parse other expressions

    some_token = self.tokens.peek();
    let unexpected = some_token.token; // null checked at the top
    let message = String::from_str("Unexpected top level token: ");
    String::append_str(message, unexpected.repr);

    throw heap::new!<LoError>(LoError {
        message: message,
        loc: unexpected.loc,
    });
};

fn LoParser::parse_fn_def(self, exported: bool): void throws &LoError {
    let fn_decl = self.parse_fn_decl()?;
    let body = self.collect_block_tokens()?;

    if self.ctx.fn_defs.contains_key(str::from_string(fn_decl.fn_name)) {
        let message = String::from_str("Cannot redefine function: ");
        String::append_str(message, str::from_string(fn_decl.fn_name));

        throw heap::new!<LoError>(LoError {
            message: message,
            loc: fn_decl.loc,
        });
    };

    if exported {
        self.ctx.fn_exports.push!<LoFnExport>(LoFnExport {
            in_name: String::clone(fn_decl.fn_name),
            out_name: String::clone(fn_decl.fn_name),
        });
    };

    let locals_last_index = fn_decl.wasm_type.inputs.size;
    let type_index = self.ctx.insert_fn_type(fn_decl.wasm_type);
    self.ctx.wasm_module.functions.push!<u32>(type_index);

    let fn_index = self.ctx.wasm_module.functions.size - 1;

    self.ctx.fn_defs.insert!<LoFnDef>(
        fn_decl.fn_name,
        LoFnDef {
            local: true,
            fn_index: fn_index,
            fn_params: fn_decl.fn_params,
            type_index: type_index,
            type_: fn_decl.lo_type,
            loc: fn_decl.loc,
        },
    );

    self.ctx.fn_bodies.push!<LoFnBody>(LoFnBody {
        fn_index: fn_index,
        type_index: type_index,
        locals: fn_decl.locals,
        locals_last_index: locals_last_index,
        body: body,
    });
};

// TODO: implement the complete version
fn LoParser::parse_fn_decl(self): LoFnDecl throws &LoError {
    let fn_name = self.tokens.expect_any(LoTokenType::Symbol)?;

    let _ = self.tokens.expect(LoTokenType::Delim, "(")?;
    let _ = self.tokens.expect(LoTokenType::Delim, ")")?;

    let fn_decl = LoFnDecl {
        fn_name: String::from_str(fn_name.repr),
        method_name: String::from_str(""),
        loc: fn_name.loc,
        fn_params: Vec::new!<LoFnParam>(),
        lo_type: LoFnType {
            inputs: Vec::new!<LoType>(),
            output: LoType::Void!(),
        },
        wasm_type: WasmFnType {
            inputs: Vec::new!<WasmValueType>(),
            outputs: Vec::new!<WasmValueType>(),
        },
        locals: StringMap::new!<LoLocalDef>(),
    };

    let lo_output = LoType::Void!();
    let some_token = self.tokens.eat(LoTokenType::Operator, ":")?;
    if some_token.exists {
        lo_output = self.parse_const_lo_type()?;
    };

    lo_output.emit_components(self.ctx, fn_decl.wasm_type.outputs);
    fn_decl.lo_type.output = lo_output;

    return fn_decl;
};

fn LoParser::collect_block_tokens(self): &LoTokenStream throws &LoError {
    let output = LoTokenStream::new(
        Vec::new!<LoToken>(),
        LoLocation::internal(),
    );

    let depth = 0;
    let _ = self.tokens.expect(LoTokenType::Delim, "{")?;

    loop {
        let some_token = self.tokens.eat(LoTokenType::Delim, "{")?;
        if some_token.exists {
            output.tokens.push!<LoToken>(some_token.token.clone());
            depth += 1;
            continue;
        };

        some_token = self.tokens.eat(LoTokenType::Delim, "}")?;
        if some_token.exists {
            if depth == 0 {
                output.terminal_token = some_token.token.clone();
                break;
            };
            output.tokens.push!<LoToken>(some_token.token.clone());
            depth -= 1;
            continue;
        };

        some_token = self.tokens.next();
        output.tokens.push!<LoToken>(some_token.token.clone());
    };

    return output;
};

struct LoBlockContents {
    exprs: &Vec::LoInstr,
    has_never: bool,
    has_return: bool,
};

// TODO: implement complete
fn LoParser::parse_block_contents(
    ctx: &LoContext, // TODO: should be LoBlockContext
    tokens: &LoTokenStream,
    expected_type: LoType,
): LoBlockContents throws &LoError {
    let contents = LoBlockContents {
        exprs: Vec::new!<LoInstr>(),
        has_never: false,
        has_return: false,
    };

    loop {
        let some_token = tokens.peek();
        if !some_token.exists {
            break;
        };

        let expr = LoParser::parse_expr(ctx, tokens, 0)?;
        let _ = tokens.expect(LoTokenType::Delim, ";")?;

        contents.exprs.push!<LoInstr>(expr);
    };

    return contents;
};

// TODO: implement complete
fn LoParser::parse_expr(
    ctx: &LoContext, // TODO: should be LoBlockContext
    tokens: &LoTokenStream,
    min_bp: u32,
): LoInstr throws &LoError {
    let some_token = tokens.eat(LoTokenType::Symbol, "return")?;
    if some_token.exists {
        return LoInstr::Return!(
            LoParser::parse_expr(ctx, tokens, min_bp)?
        );
    };

    some_token = tokens.eat_any(LoTokenType::IntLiteral)?;
    if some_token.exists {
        return LoInstr::U32Const!(*(some_token.token.value as &u32));
    };

    some_token = tokens.peek();

    let message = String::from_str("Unexpected token: ");
    String::append_str(message, LoTokenType::to_str(some_token.token.type_));
    throw heap::new!<LoError>(LoError {
        message: message,
        loc: some_token.token.loc,
    });
};

// TODO: parse other types
fn LoParser::parse_const_lo_type(self): LoType throws &LoError {
    let some_token = self.tokens.eat(LoTokenType::Symbol, "u32")?;
    if some_token.exists {
        return LoType::U32!();
    };

    throw heap::new!<LoError>(LoError {
        message: String::from_str(dbg "TODO: implement"),
        loc: LoLocation::internal(),
    });
};

// TODO: this should be in the ir.lo, but it depends on LoContext
fn LoType::emit_components(
    self, ctx: &LoContext, out: &Vec::WasmValueType
) {
    if self.kind == LoType::Void {
        return;
    };

    if self.kind == LoType::U32 {
        out.push!<WasmValueType>(WasmValueType::I32);
        return;
    };

    // TODO: support other types
    unreachable;
};

// TODO: this should be in the ir.lo, but it depends on LoContext
fn LoFnDef::get_absolute_index(self, ctx: &LoContext): u32 {
    if self.local {
        return self.fn_index + ctx.imported_fns_count;
    };

    return self.fn_index;
};
