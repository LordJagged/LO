(mem m1 :min 1000)

(export parse :as parse)
(export index_to_position :as index_to_position)

;; temporary exporting for testing
(export mem m1 :as memory)
(export skip_space :as skip_space)
(export char_at :as char_at)

(global true  bool 1)
(global false bool 0)

(global CHAR_TAB       u8 009)
(global CHAR_NEWLINE   u8 010)
(global CHAR_SPACE     u8 032)
(global CHAR_SEMICOLON u8 059)
(global CHAR_LPAREN u8 040) (global CHAR_RPAREN u8 041)
(global CHAR_LCURLY u8 123) (global CHAR_RCURLY u8 125)
(global CHAR_LBRACK u8 091) (global CHAR_RBRACK u8 093)

(struct StringSlice
    (data ptr)
    (size u32)
)

(fn StringSlice/char_at [(self StringSlice) (index u32)] [u8] (
    (load i32/u8 {{self . data} + index})
))

;; Vec
(struct &Vec (ref ptr))
(struct Vec (length u32)(capacity u32)(item_size u32)(data_ref ptr))
(fn Vec/new [(capacity u32)(item_size u32)][&Vec]({&self : &Vec}{&self = (alloc (sizeof Vec))}(store Vec &self (struct.new Vec 0 capacity item_size (alloc {capacity * item_size}))) &self ))
(fn Vec/get_u8 [(&self &Vec)(index u32)][u8]({self : Vec}{self = (load Vec &self)}(load i32/u8 {{self . data_ref} + {index * {self . item_size}}})))
(fn Vec/swap [(&self &Vec)(index1 u32)(index2 u32)][]({self : Vec}{self = (load Vec &self)}(memswap {{self . data_ref} + {index1 * {self . item_size}}}{{self . data_ref} + {index2 * {self . item_size}}}{self . item_size}) ))
(fn Vec/len [(&self &Vec)][u32]({self : Vec}{self = (load Vec &self)}{self . length}))
(fn Vec/push_u8 [(&self &Vec)(item u8)][]({self : Vec}{self = (load Vec &self)}{index : u32}{index = {self . length}}{self = length {index + 1}}(store Vec &self self)(Vec/grow_if_needed &self){self = (load Vec &self)}(store i32/u8 {{self . data_ref} + {index * {self . item_size}}} item )))
(fn Vec/push_all [(&self &Vec)(&items ptr)(items_len u32)][]({self : Vec}{self = (load Vec &self)}{old_len : u32}{old_len = {self . length}}{self = length {old_len + items_len}}(store Vec &self self)(Vec/grow_if_needed &self)(memcpy &items {{self . data_ref} + {old_len * {self . item_size}}}{items_len * {self . item_size}}) ))
(fn Vec/grow_if_needed [(&self &Vec)][]({self : Vec}{self = (load Vec &self)}(if {{self . length} == {self . capacity}}(do {new_cap : u32}{new_cap = {{self . capacity} * 2}}{old_data_ref : ptr}{old_data_ref = {self . data_ref}}{self = data_ref (alloc {new_cap * {self . item_size}})}(memcpy old_data_ref {self . data_ref}{self . capacity}){self = capacity new_cap}(free old_data_ref)))(store Vec &self self)))

;; mem utils
(global mut HEAP_INDEX u32 0)
(fn alloc [(size u32)][ptr]({ref : ptr}{ref = HEAP_INDEX}{HEAP_INDEX = {HEAP_INDEX + size}} ref ))
(fn free [(ref ptr)][]())
(fn memcpy [(src ptr)(dist ptr)(size u32)][]((loop ((if {size == 0}(break)){size = {size - 1}}(store i32/u8 {dist + size}(load i32/u8 {src + size}))))))
(fn memswap [(ref1 ptr)(ref2 ptr)(size u32)][]((loop ((if {size == 0}(break)){size = {size - 1}}{tmp : u8}{tmp = (load i32/u8 {ref1 + size})}(store i32/u8 {ref1 + size}(load i32/u8 {ref2 + size}))(store i32/u8 {ref2 + size} tmp)))))

(global SExpr/Atom u8 0)
(global SExpr/List u8 1)
(struct SExpr
    (kind u8) ; SExpr/Atom | SExpr/List
    (data ptr) ; pointer to Atom's chars or List's expr vector
)

(global ParseError/UnexpectedEOF  u32 0)
(global ParseError/UnexpectedChar u32 1)
(struct ParseResult
    (ok bool)
    (index u32)
    (data u32) ; ParseError/* or pointer to some result
)

;; TODO: test
(fn parse [(chars StringSlice)] [ParseResult] (
    {index : u32}
    {index = 0}

    {index = (skip_space chars index)}

    {&items : &Vec}
    {&items = (Vec/new 6 (sizeof SExpr))}

    (loop (
        (if {index >= {chars . size}} (break))

        {char_res : CharAtResult}
        {char_res = (char_at chars index)}

        (if (not {char_res . ok})
            (return (struct.new ParseResult
                index false ParseError/UnexpectedEOF
            ))
        )

        (if (not (is_list_start {char_res . char}))
            (return (struct.new ParseResult
                index false ParseError/UnexpectedChar
            ))
        )

        {res : ParseResult}
        {res = (parse_list chars index)}
        (if (not {res . ok}) (return res))

        (Vec/push_all &items {res . data} 1)

        {index = (skip_space chars index)}
    ))

    (struct.new ParseResult index true &items)
))

(fn parse_expr [(chars StringSlice) (index u32)] [ParseResult] (
    {char_res : CharAtResult}
    {char_res = (char_at chars index)}

    (if (not {char_res . ok})
        (return (struct.new ParseResult
            index false ParseError/UnexpectedEOF
        ))
    )

    (if (is_list_start {char_res . char})
        (return (parse_list chars index))
    )

    (parse_atom chars index)
))

(fn parse_atom [(chars StringSlice) (index u32)] [ParseResult] (
    {atom_len : u32}
    {atom_len = 0}

    (loop (
        {char_res : CharAtResult}
        {char_res = (char_at chars index)}
        (if (not {char_res . ok}) (break))
        (if (|| (||
            (is_space {char_res . char})
            (is_list_end {char_res . char}))
            {{char_res . char} == CHAR_SEMICOLON})
            (break)
        )
        {index = {index + 1}}
        {atom_len = {atom_len + 1}}
    ))

    {&atom : &Vec}
    {&atom = (Vec/new atom_len 1)} ; TODO: replace 1 with (sizeof u8)
    (Vec/push_all &atom
        {{{chars . data} + index} - atom_len}
        atom_len
    )

    {&expr : ptr}
    {&expr = (alloc (sizeof SExpr))}
    (store SExpr &expr (struct.new SExpr
        SExpr/Atom
        &atom
    ))

    (struct.new ParseResult index true &expr)
))

(fn parse_list [(chars StringSlice) (index u32)] [ParseResult] (
    {char_res : CharAtResult}
    {char_res = (char_at chars index)}

    {list_start_char : u8}
    {list_start_char = {char_res . char}}
    {index = {index + 1}} ; eat list start

    {index = (skip_space chars index)}

    {&items : &Vec}
    {&items = (Vec/new 6 (sizeof SExpr))}

    (loop (
        {char_res = (char_at chars index)}
        (if (not {char_res . ok})
            (return (struct.new ParseResult
                index false ParseError/UnexpectedEOF
            ))
        )

        (if (is_list_end {char_res . char})
            (break)
        )

        {res : ParseResult}
        {res = (parse_expr chars index)}
        (if (not {res . ok}) (return res))

        (Vec/push_all &items {res . data} 1)

        {index = (skip_space chars index)}
    ))

    {char_res = (char_at chars index)}
    (if (not {char_res . ok})
        (return (struct.new ParseResult
            index false ParseError/UnexpectedEOF
        ))
    )

    {list_end_char : u8}
    {list_end_char = {char_res . char}}
    {index = {index + 1}} ; eat list end

    (if (not (is_valid_list_chars list_start_char list_end_char))
        (return (struct.new ParseResult
            index false ParseError/UnexpectedEOF
        ))
    )

    (if {{list_start_char == CHAR_LCURLY} && {(Vec/len &items) >= 2}}
        (Vec/swap &items 0 1)
    )

    {&expr : ptr}
    {&expr = (alloc (sizeof SExpr))}
    (store SExpr &expr (struct.new SExpr
        SExpr/List
        &items
    ))

    (struct.new ParseResult index true &expr)
))

;; TODO: test comment skipping
(fn skip_space [(chars StringSlice) (index u32)] [u32] (
    {char_res : CharAtResult}

    (loop (
        {char_res = (char_at chars index)}
        (if (not {char_res . ok}) (break))
        (if (not (is_space {char_res . char})) (break))
        {index = {index + 1}}
    ))

    (if {{char_res . ok} && {{char_res . char} == CHAR_SEMICOLON}} (do
        {index = {index + 1}}

        (loop (
            {char_res = (char_at chars index)}
            (if (not {char_res . ok}) (break))
            (if {{char_res . char} == CHAR_NEWLINE} (break))
            {index = {index + 1}}
        ))

        (if {{char_res . ok} && {{char_res . char} == CHAR_SEMICOLON}}
            {index = {index + 1}}
        )

        (return (skip_space chars index))
    ))

    index
))

(fn is_list_start [(char u8)] [bool] (
    (|| (||
    {char == CHAR_LPAREN}
    {char == CHAR_LCURLY})
    {char == CHAR_LBRACK})
))

(fn is_list_end [(char u8)] [bool] (
    (|| (||
    {char == CHAR_RPAREN}
    {char == CHAR_RCURLY})
    {char == CHAR_RBRACK})
))

(fn is_valid_list_chars [(start u8) (end u8)] [bool] (
    (|| (||
    {{start == CHAR_LPAREN} && {end == CHAR_RPAREN}}
    {{start == CHAR_LCURLY} && {end == CHAR_RCURLY}})
    {{start == CHAR_LBRACK} && {end == CHAR_RBRACK}})
))

(fn is_space [(char u8)] [bool] (
    (|| (||
    {char == CHAR_SPACE}
    {char == CHAR_NEWLINE})
    {char == CHAR_TAB})
))

(struct CharAtResult (ok bool) (char u8))

(fn char_at [(chars StringSlice) (index u32)] [CharAtResult] (
    (if {index >= {chars . size}}
        (return (struct.new CharAtResult false 0))
    )

    (struct.new CharAtResult true (StringSlice/char_at chars index))
))

(fn index_to_position [(chars StringSlice) (index u32)] [
    u32 ; line
    u32 ; col
] (
    {line : u32}
    {col : u32}
    {(line col) = (pack 1 1)}

    {char_index : u32}
    {char_index = 0}
    (loop (
        (if {char_index >= {chars . size}} (break))
        (if {char_index >= index} (break))

        {char : u32}
        {char = (StringSlice/char_at chars char_index)}

        (if {char == CHAR_NEWLINE} (do
            {col = 1}
            {line = {line + 1}}
            {char_index = {char_index + 1}}
            (continue)
        ))

        {col = {col + 1}}
        {char_index = {char_index + 1}}
    ))

    (pack line col)
))
