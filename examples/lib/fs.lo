include "./std.lo";

struct fs {};

// fs expects host to preopen "." on fd 3
const fs::CWD_PREOPEN_FD = 3;

// TODO: return errors instead of exiting with logs
fn fs::read_file(file_name: str): &String {
    let open_res = fs::open(file_name);
    if open_res.err != 0 {
        fputs(wasi::FD_STDERR, "Error opening file: ");
        fputs(wasi::FD_STDERR, file_name);
        fputs(wasi::FD_STDERR, "\n");
        wasi::proc_exit(1);
    };
    let fd = open_res.fd;

    return fs::read_fd(fd);
};

struct fs::FdOpenRes {
    err: wasi::Err,
    fd: u32,
};

fn fs::open(file_path: str): fs::FdOpenRes {
    let fd_ref = tmp_alloc!<u32>();

    let err = wasi::path_open(
        fs::CWD_PREOPEN_FD, 0,
        file_path.data, file_path.size, 0, 2u64, 0u64, 0,
        fd_ref,
    );

    return fs::FdOpenRes { err: err, fd: *fd_ref };
};

fn fs::read_fd(fd: u32): &String {
    let output = Vec::with_capacity!<u8>(256);

    let chunk = tmp_alloc_many!<u8>(256);

    let in_vec = tmp_alloc!<wasi::IOVec>();
    *in_vec = wasi::IOVec { base: chunk, size: 256 };

    let nread_ref = tmp_alloc!<u32>();

    loop {
        let _err = wasi::fd_read(fd, in_vec, 1, nread_ref);

        let nread = *nread_ref;
        if nread == 0 {
            break;
        };

        output.push_all(chunk as &(), nread);
    };

    return output;
};


fn fs::pipe(fd_in: u32, fd_out: u32, chunk_size: u32): bool {
    let chunk = tmp_alloc_many!<u8>(chunk_size);

    let iov = tmp_alloc!<wasi::IOVec>();
    *iov = wasi::IOVec { base: chunk, size: 0 };

    let nread_ref = tmp_alloc!<u32>();

    loop {
        iov.size = chunk_size;
        let io_res = wasi::fd_read(fd_in, iov, 1, nread_ref);
        if io_res != 0 {
            return false;
        };

        let nread = *nread_ref;
        if nread == 0 {
            break;
        };

        iov.size = nread;
        io_res = wasi::fd_write(fd_out, iov, 1, nread_ref);
        if io_res != 0 {
            return false;
        };
    };

    return true;
};

fn fs::close(fd: u32) {
    let _ = wasi::fd_close(fd); // TODO: ignore close error?
};
