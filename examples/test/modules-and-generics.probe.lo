struct std::Vec::<T> {
    // ...
};

fn std::Vec::<T>::new() -> std::Vec::<T> {
    // ...
}

fn std::Vec::<T>::push(&self, value: T) {
    // ...
};

let items = std::Vec::<u32>::new();

// function call resolution:
// - get method name: `push`
// - get receiver type: `std::Vec::<u32>`
// - add `Self = std::Vec::<u32>`, `T = u32` to type scope:
//   - resolve arguments: `value: u32`
// resolved function name:
//   `std::Vec::<u32>::push`
items.push(1);

///////////////////////////////////////

struct std::Vec::<T> {
    items: &* T,
    capacity: u32,
    size: u32,
    alloc_id: u32,
};

fn std::Vec::<T>::new() -> &Self {
    return Self::new_using(ALLOC_HEAP);
};

fn std::Vec::<T>::new_using(alloc_id: u32) -> Self {
    return std::new_using::<Self>(alloc_id, Self {
        items: std::alloc_many::<T>(10),
        capacity: 10,
        size: 0,
    });
};

fn std::Vec::<T>::push(&self, value: T) {
    self->size += 1;
    self.grow_if_needed();

    return self.at_unchecked(self->size - 1);
};

fn std::Vec::<T>::at_unchecked(&self, index: u32) -> &T {
    return (self->data as u32 + index * sizeof T) as &T;
};

fn std::Vec::<T>::grow_if_needed(&self) {
    if self->size != self->capacity {
        return;
    };

    if std::mem::is_stack_ptr(self->data) {
        panic("Attempt to grow stack allocated vector");
    };

    let old_data = self->data;
    defer std::free_many::<T>(old_data, self->capacity);

    self->capacity += self->capacity / 2;
    self->data = std::alloc_many::<T>(self->capacity);

    std::mem::copy_many::<T>(old_data, self->data, self->size);
};

fn std::mem::copy_many::<T>(src: &* T, dist: &* T, size: u32) {
    loop {
        if size == 0 {
            break;
        };

        size -= 1;

        *((dist as u32 + size) as &u8) = *((src as u32 + size) as &u8);
    };
};
