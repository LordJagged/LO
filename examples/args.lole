(mem m1 :min 1000)
(export mem m1 :as memory)

(struct &*u8 (actual ptr))
(struct &*&*u8 (actual ptr))

;; <std>
    (global true bool 1)
    (global false bool 0)

    (struct &Vec<u8> (actual ptr))
    
    ;; ascii digits: 48-57
    (fn std/u32_to_string [(input u32)] [&Vec<u8>] (
        {&output : &Vec<u8>}
        {&output = (Vec/new 32 1)}

        (if {input == 0} (do
            (Vec/push_u8 &output 48)
            (return &output)
        ))

        (loop (
            {rem : u32}
            {rem = {input % 10}}
            (if {rem == 0} (break))
        
            (Vec/push_u8 &output {48 + rem})
            {input = {input / 10}}
        ))
        
        (Vec/reverse &output)

        (return &output)
    ))
;; </std>

;; <string>
    (struct StringSlice (data ptr)(size u32))
    (fn StringSlice/Parser/char_at [(self StringSlice)(index u32)][u8]((load i32/u8 {{self . data} + index})))
;; </string>

;; <vec>
    (struct &Vec (ref ptr))
    (struct Vec (length u32)(capacity u32)(item_size u32)(data_ref ptr))
    (fn Vec/new [(capacity u32)(item_size u32)][&Vec]({&self : &Vec}{&self = (Mem/alloc (sizeof Vec))}(store Vec &self (struct.new Vec 0 capacity item_size (Mem/alloc {capacity * item_size}))) &self))
    (fn Vec/get_u8 [(&self &Vec)(index u32)][u8]({self : Vec}{self = (load Vec &self)}(load i32/u8 {{self . data_ref} + {index * {self . item_size}}})))
    (fn Vec/get_u32 [(&self &Vec)(index u32)][u32]({self : Vec}{self = (load Vec &self)}(load i32 {{self . data_ref} + {index * {self . item_size}}})))
    (fn Vec/swap [(&self &Vec)(index1 u32)(index2 u32)][]({self : Vec}{self = (load Vec &self)}(Mem/swap {{self . data_ref} + {index1 * {self . item_size}}}{{self . data_ref} + {index2 * {self . item_size}}}{self . item_size})))
    (fn Vec/len [(&self &Vec)][u32]({self : Vec}{self = (load Vec &self)}{self . length}))
    (fn Vec/push_u8 [(&self &Vec)(item u8)][]({self : Vec}{self = (load Vec &self)}{index : u32}{index = {self . length}}{self = length {index + 1}}(store Vec &self self)(Vec/grow_if_needed &self){self = (load Vec &self)}(store i32/u8 {{self . data_ref} + {index * {self . item_size}}} item)))
    (fn Vec/push_all [(&self &Vec)(&items ptr)(items_len u32)][]({self : Vec}{self = (load Vec &self)}{old_len : u32}{old_len = {self . length}}{self = length {old_len + items_len}}(store Vec &self self)(Vec/grow_if_needed &self){self = (load Vec &self)}(Mem/copy &items {{self . data_ref} + {old_len * {self . item_size}}}{items_len * {self . item_size}})))
    (fn Vec/grow_if_needed [(&self &Vec)][]({self : Vec}{self = (load Vec &self)}(if {{self . length} == {self . capacity}}(do {new_cap : u32}{new_cap = {{self . capacity} * 2}}{old_data_ref : ptr}{old_data_ref = {self . data_ref}}{self = data_ref (Mem/alloc {new_cap * {self . item_size}})}(Mem/copy old_data_ref {self . data_ref}{self . capacity}){self = capacity new_cap}(Mem/free old_data_ref)))(store Vec &self self)))
    (fn Vec/reverse [(&self &Vec)] [] (
        {start : u32}
        {start = 0}
        {end : u32}
        {end = {(Vec/len &self) - 1}}
        
        (loop (
            (if {start >= end} (break))

            (Vec/swap &self start end)
            {start = {start + 1}}
            {end = {end - 1}}
        ))
    ))
;; </vec>

;; <mem>
    (global mut Mem/HEAP_INDEX u32 4) ;; 0-4 is for Wasi/fd_write nwritten 
    (fn Mem/alloc [(size u32)][ptr]({ref : ptr}{ref = Mem/HEAP_INDEX}{Mem/HEAP_INDEX = {Mem/HEAP_INDEX + size}} ref))
    (fn Mem/free [(ref ptr)][]())
    (fn Mem/copy [(src ptr)(dist ptr)(size u32)][]((loop ((if {size == 0}(break)){size = {size - 1}}(store i32/u8 {dist + size}(load i32/u8 {src + size}))))))
    (fn Mem/swap [(ref1 ptr)(ref2 ptr)(size u32)][]((loop ((if {size == 0}(break)){size = {size - 1}}{tmp : u8}{tmp = (load i32/u8 {ref1 + size})}(store i32/u8 {ref1 + size}(load i32/u8 {ref2 + size}))(store i32/u8 {ref2 + size} tmp)))))
;; </mem>

;; <wasi>
    (global FD_STDOUT u32 1)
    (struct &u32 (actual ptr))
    (struct &IOVec* (actual ptr))
    (struct IOVec (base ptr) (len u32))
    (import fn fd_write [
        (file_descriptor u32) ;; file_descriptor
        (&iovs           &IOVec*) ;; The pointer to the iov array
        (iovs_len        u32) ;; Amount of IOVec
        (&nwritten       u32) ;; Pointer to store the number of bytes written
    ] [i32] :from wasi_snapshot_preview1 fd_write)
    (import fn args_sizes_get [
        (&argc          &u32) ;; Pointer to where the number of arguments will be written.
        (&argv_buf_size &u32) ;; Pointer to where the size of the argument string data will be written.
    ] [i32] :from wasi_snapshot_preview1 args_sizes_get)
    (import fn args_get [
        (&argv     &u32) ;; Pointer to a buffer where the argument pointers will be written.
        (&argv_buf &u32) ;; Pointer to a buffer where the argument string data will be written.
    ] [i32] :from wasi_snapshot_preview1 args_get)
;; </wasi>

;; <args>
    (struct Args
        (argc u32)
        (&argv ptr) ;; &*&*u8
    )

    (fn Args/load [] [Args] (
        {&argc : &u32}
        {&argc = (Mem/alloc (sizeof u32))}
        
        {&argv_buf_size : &u32}
        {&argv_buf_size = (Mem/alloc (sizeof u32))}

        {_ : i32}
        {_ = (args_sizes_get &argc &argv_buf_size)}

        {argc : u32}
        {argc = (load i32 &argc)}

        {&argv : &*&*u8}
        {&argv = (Mem/alloc {argc * (sizeof &*u8)})}

        {&argv_buf : &*u8}
        {&argv_buf = (Mem/alloc (load i32 &argv_buf_size))}

        {_ = (args_get &argv &argv_buf)}

        (return (struct.new Args
            argc
            &argv
        ))
    ))

    (fn Args/get [(self Args) (i u32)] [StringSlice] (
        {&arg : &*u8}
        {&arg = (load i32 {{self . &argv} + {i * (sizeof &*u8)}})}
        (return (struct.new StringSlice
            &arg (Args/_c_str_len &arg)
        ))
    ))

    (fn Args/_c_str_len [(&str &*u8)] [u32] (
        {len : u32}
        {len = 0}
        
        (loop (
            {char : u8}
            {char = (load i32/u8 {&str + len})}
            
            (if {char == 0} (break))

            {len = {len + 1}}
        ))

        (return len)
    ))
;; </args>

;; <print>
    (fn print_u32 [(num u32)] [] (
        {&out : &Vec<u8>}
        {&out = (std/u32_to_string num)}

        (print_str &out)
    ))

    (fn println [] [] (
        {&out : &*u8}
        {&out = (Mem/alloc 1)}
        (store i32/u8 &out 10) ;; \n

        (print_str_slice (pack &out 1))
    ))

    (fn print_str [(&str &Vec<u8>)] [] (
        {str : Vec}
        {str = (load Vec &str)}

        (print_str_slice (pack
            {str . data_ref}
            {str . length}
        ))
    ))

    (fn print_str_slice [(str StringSlice)] [] (
        {&io_vec : &IOVec*}
        {&io_vec = (Mem/alloc (sizeof StringSlice))}
        (store StringSlice &io_vec str)

        {&nwritten : &u32}
        {&nwritten = (Mem/alloc (sizeof u32))}

        {io_res : i32}
        {io_res = (fd_write FD_STDOUT &io_vec 1 &nwritten)}
    ))
;; </print>

(export main :as _start)
(fn main [] [i32] (
    {args : Args}
    {args = (Args/load)}

    {i : u32}
    {i = 0}
    (loop (
        (if {i == {args . argc}} (break))

        {arg : StringSlice}
        {arg = (Args/get args i)}

        (print_str_slice arg)
        (println)

        {i = {i + 1}}
    ))
    
    (return 0)
))
