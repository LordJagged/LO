(mem m1 :min 1000)
(export mem m1 :as memory)

;; Good stuff
(global true bool 1)
(global false bool 0)

;; #region Imports

;; Strings
(struct StringSlice (data ptr)(size u32))
(fn StringSlice/Parser/char_at [(self StringSlice)(index u32)][u8]((load i32/u8 {{self . data} + index})))

;; Vec
(struct &Vec (ref ptr))
(struct Vec (length u32)(capacity u32)(item_size u32)(data_ref ptr))
(fn Vec/new [(capacity u32)(item_size u32)][&Vec]({&self : &Vec}{&self = (Mem/alloc (sizeof Vec))}(store Vec &self (struct.new Vec 0 capacity item_size (Mem/alloc {capacity * item_size}))) &self))
(fn Vec/get_u8 [(&self &Vec)(index u32)][u8]({self : Vec}{self = (load Vec &self)}(load i32/u8 {{self . data_ref} + {index * {self . item_size}}})))
(fn Vec/get_u32 [(&self &Vec)(index u32)][u32]({self : Vec}{self = (load Vec &self)}(load i32 {{self . data_ref} + {index * {self . item_size}}})))
(fn Vec/swap [(&self &Vec)(index1 u32)(index2 u32)][]({self : Vec}{self = (load Vec &self)}(Mem/swap {{self . data_ref} + {index1 * {self . item_size}}}{{self . data_ref} + {index2 * {self . item_size}}}{self . item_size})))
(fn Vec/len [(&self &Vec)][u32]({self : Vec}{self = (load Vec &self)}{self . length}))
(fn Vec/push_u8 [(&self &Vec)(item u8)][]({self : Vec}{self = (load Vec &self)}{index : u32}{index = {self . length}}{self = length {index + 1}}(store Vec &self self)(Vec/grow_if_needed &self){self = (load Vec &self)}(store i32/u8 {{self . data_ref} + {index * {self . item_size}}} item)))
(fn Vec/push_all [(&self &Vec)(&items ptr)(items_len u32)][]({self : Vec}{self = (load Vec &self)}{old_len : u32}{old_len = {self . length}}{self = length {old_len + items_len}}(store Vec &self self)(Vec/grow_if_needed &self){self = (load Vec &self)}(Mem/copy &items {{self . data_ref} + {old_len * {self . item_size}}}{items_len * {self . item_size}})))
(fn Vec/grow_if_needed [(&self &Vec)][]({self : Vec}{self = (load Vec &self)}(if {{self . length} == {self . capacity}}(do {new_cap : u32}{new_cap = {{self . capacity} * 2}}{old_data_ref : ptr}{old_data_ref = {self . data_ref}}{self = data_ref (Mem/alloc {new_cap * {self . item_size}})}(Mem/copy old_data_ref {self . data_ref}{self . capacity}){self = capacity new_cap}(Mem/free old_data_ref)))(store Vec &self self)))

;; Mem utils
(global mut Mem/HEAP_INDEX u32 4) ;; 0-4 is for Wasi/fd_write nwritten 
(fn Mem/alloc [(size u32)][ptr]({ref : ptr}{ref = Mem/HEAP_INDEX}{Mem/HEAP_INDEX = {Mem/HEAP_INDEX + size}} ref))
(fn Mem/free [(ref ptr)][]())
(fn Mem/copy [(src ptr)(dist ptr)(size u32)][]((loop ((if {size == 0}(break)){size = {size - 1}}(store i32/u8 {dist + size}(load i32/u8 {src + size}))))))
(fn Mem/swap [(ref1 ptr)(ref2 ptr)(size u32)][]((loop ((if {size == 0}(break)){size = {size - 1}}{tmp : u8}{tmp = (load i32/u8 {ref1 + size})}(store i32/u8 {ref1 + size}(load i32/u8 {ref2 + size}))(store i32/u8 {ref2 + size} tmp)))))

;; Parser
(global Parser/SExpr/Atom u8 0)
(global Parser/SExpr/List u8 1)
(struct Parser/SExpr (kind u8)(data ptr))
(global Parser/ParseError/UnexpectedEOF u32 0)
(global Parser/ParseError/UnexpectedChar u32 1)
(struct Parser/ParseResult (ok bool)(index u32)(data u32))
(global CHAR_TAB u8 009)(global CHAR_NEWLINE u8 010)(global CHAR_SPACE u8 032)(global CHAR_SEMICOLON u8 059)(global CHAR_LPAREN u8 040)(global CHAR_RPAREN u8 041)(global CHAR_LCURLY u8 123)(global CHAR_RCURLY u8 125)(global CHAR_LBRACK u8 091)(global CHAR_RBRACK u8 093)
(fn Parser/parse [(chars StringSlice)][Parser/ParseResult]({index : u32}{index = 0}{index = (Parser/skip_space chars index)}{&items : &Vec}{&items = (Vec/new 6 (sizeof Parser/SExpr))}(loop ((if {index >= {chars . size}}(break)){char_res : Parser/CharAtResult}{char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedEOF)))(if (not (Parser/is_list_start {char_res . char}))(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedChar))){res : Parser/ParseResult}{res = (Parser/parse_list chars index)}(if (not {res . ok})(return res))(Vec/push_all &items {res . data} 1){index = (Parser/skip_space chars {res . index})}))(struct.new Parser/ParseResult true index &items)))
(fn Parser/parse_expr [(chars StringSlice)(index u32)][Parser/ParseResult]({char_res : Parser/CharAtResult}{char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedEOF)))(if (Parser/is_list_start {char_res . char})(return (Parser/parse_list chars index)))(Parser/parse_atom chars index)))
(fn Parser/parse_atom [(chars StringSlice)(index u32)][Parser/ParseResult]({atom_len : u32}{atom_len = 0}(loop ({char_res : Parser/CharAtResult}{char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(break))(if (|| (|| (Parser/is_space {char_res . char})(Parser/is_list_end {char_res . char})){{char_res . char} == CHAR_SEMICOLON})(break)){index = {index + 1}}{atom_len = {atom_len + 1}})){&atom : &Vec}{&atom = (Vec/new atom_len 1)}(Vec/push_all &atom {{{chars . data} + index} - atom_len} atom_len){&expr : ptr}{&expr = (Mem/alloc (sizeof Parser/SExpr))}(store Parser/SExpr &expr (struct.new Parser/SExpr Parser/SExpr/Atom &atom))(struct.new Parser/ParseResult true index &expr)))
(fn Parser/parse_list [(chars StringSlice)(index u32)][Parser/ParseResult]({char_res : Parser/CharAtResult}{char_res = (Parser/char_at chars index)}{list_start_char : u8}{list_start_char = {char_res . char}}{index = {index + 1}}{index = (Parser/skip_space chars index)}{&items : &Vec}{&items = (Vec/new 6 (sizeof Parser/SExpr))}(loop ({char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedEOF)))(if (Parser/is_list_end {char_res . char})(break)){res : Parser/ParseResult}{res = (Parser/parse_expr chars index)}(if (not {res . ok})(return res))(Vec/push_all &items {res . data} 1){index = (Parser/skip_space chars {res . index})})){char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedEOF))){list_end_char : u8}{list_end_char = {char_res . char}}{index = {index + 1}}(if (not (Parser/is_valid_list_chars list_start_char list_end_char))(return (struct.new Parser/ParseResult false index Parser/ParseError/UnexpectedEOF)))(if {{list_start_char == CHAR_LCURLY} && {(Vec/len &items) >= 2}}(Vec/swap &items 0 1)){&expr : ptr}{&expr = (Mem/alloc (sizeof Parser/SExpr))}(store Parser/SExpr &expr (struct.new Parser/SExpr Parser/SExpr/List &items))(struct.new Parser/ParseResult true index &expr)))
(fn Parser/skip_space [(chars StringSlice)(index u32)][u32]({char_res : Parser/CharAtResult}(loop ({char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(break))(if (not (Parser/is_space {char_res . char}))(break)){index = {index + 1}}))(if {{char_res . ok} && {{char_res . char} == CHAR_SEMICOLON}}(do {index = {index + 1}}(loop ({char_res = (Parser/char_at chars index)}(if (not {char_res . ok})(break))(if {{char_res . char} == CHAR_NEWLINE}(break)){index = {index + 1}}))(if {{char_res . ok} && {{char_res . char} == CHAR_SEMICOLON}}{index = {index + 1}})(return (Parser/skip_space chars index)))) index))
(fn Parser/is_list_start [(char u8)][bool]((|| (|| {char == CHAR_LPAREN}{char == CHAR_LCURLY}){char == CHAR_LBRACK})))
(fn Parser/is_list_end [(char u8)][bool]((|| (|| {char == CHAR_RPAREN}{char == CHAR_RCURLY}){char == CHAR_RBRACK})))
(fn Parser/is_valid_list_chars [(start u8)(end u8)][bool]((|| (|| {{start == CHAR_LPAREN} && {end == CHAR_RPAREN}}{{start == CHAR_LCURLY} && {end == CHAR_RCURLY}}){{start == CHAR_LBRACK} && {end == CHAR_RBRACK}})))
(fn Parser/is_space [(char u8)][bool]((|| (|| {char == CHAR_SPACE}{char == CHAR_NEWLINE}){char == CHAR_TAB})))
(struct Parser/CharAtResult (ok bool)(char u8))
(fn Parser/char_at [(chars StringSlice)(index u32)][Parser/CharAtResult]((if {index >= {chars . size}}(return (struct.new Parser/CharAtResult false 0)))(struct.new Parser/CharAtResult true (StringSlice/Parser/char_at chars index))))
(fn Parser/index_to_position [(chars StringSlice)(index u32)][ u32 u32]({line : u32}{col : u32}{(line col) = (pack 1 1)}{char_index : u32}{char_index = 0}(loop ((if {char_index >= {chars . size}}(break))(if {char_index >= index}(break)){char : u32}{char = (StringSlice/Parser/char_at chars char_index)}(if {char == CHAR_NEWLINE}(do {col = 1}{line = {line + 1}}{char_index = {char_index + 1}}(continue))){col = {col + 1}}{char_index = {char_index + 1}}))(pack line col))) 

;; WASI
(global Wasi/FD_STDOUT u32 1)
(struct Wasi/IOVec (base ptr)(len u32))
(struct &Wasi/IOVec (actual ptr))
(import fn Wasi/fd_write [(file_descriptor u32)(&iovs ptr)(iovs_len u32)(&nwritten u32)][i32] :from wasi_snapshot_preview1 fd_write)
(fn Std/print [(&iov &Wasi/IOVec)][]({_ : i32}{_ = (Wasi/fd_write Wasi/FD_STDOUT &iov 1 0)})) 

;; #endregion

(struct MinifyResult (ok bool) (data ptr))

(struct &Vec<Parser/SExpr> (actual ptr))
(struct &Vec<u8> (actual ptr))

(export main :as _start)
(fn main [(chars StringSlice)] [i32] (
    {parse_res : Parser/ParseResult}
    {parse_res = (Parser/parse chars)}

    (if (not {parse_res . ok}) (do
        (return 1)
    ))

    {&exprs : &Vec<Parser/SExpr>}
    {&exprs = {parse_res . data}}
    {i : u32}
    {i = 0}
    ;; TODO: implement dump
    ;; {&output : &Vec<u8>}
    ;; {&output = (Vec/new 256 1)}

    (loop (
        (if {i == (Vec/len &exprs)}
            (break)
        )

        ;; TODO: implement dump
        ;; {expr : Parser/SExpr}
        ;; {expr = (load Parser/SExpr {&exprs + {i * (sizeof Parser/SExpr)}})}
        ;; (dump_expr expr &output)

        {i = {i + 1}}
    ))

    {&str : &Vec<u8>}
    {&str = (u32_to_string i)}
    (Vec/push_u8 &str CHAR_NEWLINE)
    
    {str : Vec}
    {str = (load Vec &str)}
    
    {&out_str : ptr}
    {&out_str = (Mem/alloc (sizeof StringSlice))}
    (store StringSlice &out_str (struct.new StringSlice
        {str . data_ref}
        {str . length}
    ))
    (Std/print &out_str)

    (return 0)
))

;; ascii digits: 48-57
(fn u32_to_string [(input u32)] [&Vec<u8>] (
    {&output : &Vec<u8>}
    {&output = (Vec/new 32 1)}

    (if {input == 0} (do
        (Vec/push_u8 &output 48)
        (return &output)
    ))

    (loop (
        {rem : u32}
        {rem = {input % 10}}
      
        (Vec/push_u8 &output {48 + rem})
        {input = {input / 10}}
        
        (if {input == 0} (break))
    ))
    
    (Vec/reverse &output)

    (return &output)
))

(fn Vec/reverse [(&self &Vec)] [] (
    {start : u32}
    {start = 0}
    {end : u32}
    {end = {(Vec/len &self) - 1}}
    
    (loop (
        (if {start >= end} (break))

        (Vec/swap &self start end)
        {start = {start + 1}}
        {end = {end - 1}}
    ))
))

;; TODO: implement dump
;; (fn dump_expr [(expr Parser/SExpr) (&output &Vec)] [] (
    
;; ))
