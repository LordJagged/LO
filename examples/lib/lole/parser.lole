(mod lib/std)
(mod lib/lole/ast)

(struct Lole/Parser
    (file_name StringSlice)
    (chars StringSlice)
    (index u32)
    (line u32)
    (col u32)
)

(struct Lole/Parser/ParseResult
    (ok bool)
    (data (& void)) ; (& Lole/Ast/SExpr) | (& Lole/Ast/CompileError)
)

(struct Lole/Parser/ParseScriptResult
    (ok bool)
    (data (& void)) ; (& Vec<Lole/Ast/SExpr>) | (& Lole/Ast/CompileError)
)

; public interface
(fn Lole/Parser/parse [(file_name StringSlice) (script StringSlice)] Lole/Parser/ParseScriptResult (
    {&parser := (new Lole/Parser (Lole/Parser/new file_name script)
        :using Alloc/STACK)}
    (defer (free Alloc/STACK &parser (sizeof Lole/Parser)))

    (return (Lole/Parser/parse_all &parser))
))

(fn Lole/Parser/new [(file_name StringSlice) (script StringSlice)] Lole/Parser (
    (return (Lole/Parser
        :file_name file_name
        :chars script
        :index {0 as u32}
        :line {1 as u32}
        :col {1 as u32}
    ))
))

(fn Lole/Parser/parse_all [(&self (& Lole/Parser))] Lole/Parser/ParseScriptResult (
    (Lole/Parser/skip_space &self)

    {&items := (Vec/new 10 (sizeof Lole/Ast/SExpr))}

    (loop (
        ; TODO: support chaining `->`
        (if {&self -> index >= {&self -> chars . size}} (do
            (break)
        ))

        {res := (Lole/Parser/current_char &self)}
        (if (not {res . ok}) (return res))

        (if (not (Lole/Parser/is_list_start {res . data})) (do
            (return (Lole/Parser/ParseScriptResult
                :ok false
                :data {(Lole/Parser/err_unexpected_char &self) as (& void)}
            ))
        ))

        {expr_res := (Lole/Parser/parse_list &self)}
        (if (not {expr_res . ok}) (return expr_res))

        (Lole/Parser/skip_space &self)

        (Vec/push_all &items {expr_res . data} 1)
    ))

    (return (Lole/Parser/ParseScriptResult
        :ok true
        :data {&items as (& void)}
    ))
))

(fn Lole/Parser/parse_expr [(&self (& Lole/Parser))] Lole/Parser/ParseResult (
    {res := (Lole/Parser/current_char &self)}
    (if (not {res . ok}) (return res))

    (if (Lole/Parser/is_list_start {res . data}) (do
        (return (Lole/Parser/parse_list &self))
    ))

    (return (Lole/Parser/parse_atom &self))
))

(fn Lole/Parser/parse_atom [(&self (& Lole/Parser))] Lole/Parser/ParseResult (
    {res := (Lole/Parser/current_char &self)}
    (if (not {res . ok}) (return res))

    (if {res . data == (char_code "\"")} (do
        (return (Lole/Parser/parse_string &self))
    ))

    (return (Lole/Parser/parse_symbol &self))
))

(fn Lole/Parser/parse_string [(&self (& Lole/Parser))] Lole/Parser/ParseResult (
    {loc := (Lole/Parser/loc &self)}

    (Lole/Parser/next_char &self) ; skip start quote

    {&value := (String/new 6)}

    (loop (
        {res := (Lole/Parser/current_char &self)}
        (if (not {res . ok}) (return res))

        (if {res . data == (char_code "\"")} (do
            (break)
        ))

        (if {res . data != (char_code "\\")} (do
            (Vec/push_u8 &value {res . data})
            (Lole/Parser/next_char &self)
            (continue)
        ))
        (Lole/Parser/next_char &self) ; skip '\'

        {res = (Lole/Parser/current_char &self)}
        (if (not {res . ok}) (return res))

        (if {res . data == (char_code "n")} (do
            (Vec/push_u8 &value (char_code "\n"))
            (Lole/Parser/next_char &self)
            (continue)
        ))

        (if {res . data == (char_code "t")} (do
            (Vec/push_u8 &value (char_code "\t"))
            (Lole/Parser/next_char &self)
            (continue)
        ))

        (if {res . data == (char_code "\\")
                || {res . data == (char_code "\"")}} (do
            (Vec/push_u8 &value {res . data})
            (Lole/Parser/next_char &self)
            (continue)
        ))

        (return (Lole/Parser/ParseResult
            :ok false
            :data {(Lole/Parser/err_unexpected_char &self) as (& void)}
        ))
    ))

    (Lole/Parser/next_char &self) ; skip end quote

    {loc . length = {&self -> index - {loc . offset}}}

    (return (Lole/Parser/ParseResult
        :ok true
        :data {(new Lole/Ast/SExpr (do
            Lole/Ast/SExpr/ATOM
            (new Lole/Ast/SExpr/Atom (do
                &value
                Lole/Ast/AtomKind/STRING
                loc
            ))
        )) as (& void)}
    ))
))

(fn Lole/Parser/parse_symbol [(&self (& Lole/Parser))] Lole/Parser/ParseResult (
    {loc := (Lole/Parser/loc &self)}

    (loop (
        {res := (Lole/Parser/current_char &self)}
        (if {(Lole/Parser/is_space {res . data})
                || (Lole/Parser/is_list_end {res . data})
                || {res . data == (char_code ";")}} (do
            (break)
        ))
        (Lole/Parser/next_char &self)
    ))

    {loc . length = {&self -> index - {loc . offset}}}

    {&value := (String/from_slice
        {&self -> chars . data + {loc . offset}} {loc . length}) }

    (return (Lole/Parser/ParseResult
        :ok true
        :data {(new Lole/Ast/SExpr (do
            Lole/Ast/SExpr/ATOM
            (new Lole/Ast/SExpr/Atom (do
                &value
                Lole/Ast/AtomKind/SYMBOL
                loc
            ))
        )) as (& void)}
    ))
))

(fn Lole/Parser/parse_list [(&self (& Lole/Parser))] Lole/Parser/ParseResult (
    {loc := (Lole/Parser/loc &self)}
    {res : Lole/Parser/CharAtResult}

    {res = (Lole/Parser/current_char &self)}
    (if (not {res . ok}) (return res))
    ; TODO: use `:=`
    {list_start_char : u8 = {res . data}}
    (Lole/Parser/next_char &self) ; eat list start

    (Lole/Parser/skip_space &self)

    {&items := (Vec/new 6 (sizeof Lole/Ast/SExpr))}

    (loop (
        {res = (Lole/Parser/current_char &self)}
        (if (not {res . ok}) (return res))

        (if (Lole/Parser/is_list_end {res . data}) (do
            (break)
        ))

        {expr_res := (Lole/Parser/parse_expr &self)}
        (if (not {expr_res . ok}) (return expr_res))
        (Vec/push_all &items {expr_res . data} 1)

        (Lole/Parser/skip_space &self)
    ))

    {res = (Lole/Parser/current_char &self)}
    (if (not {res . ok}) (return res))
    ; TODO: use `:=`
    {list_end_char : u8 = {res . data}}
    (Lole/Parser/next_char &self) ; eat list end

    {loc . length = {&self -> index - {loc . offset}}}

    (if {list_start_char == (char_code "{") && {(Vec/len &items) >= 2}} (do
        (return (Lole/Parser/m_expr_to_s_expr_and_validate &items loc))
    ))

    (return (Lole/Parser/ParseResult
        :ok true
        :data {(new Lole/Ast/SExpr (do
            Lole/Ast/SExpr/LIST
            (new Lole/Ast/SExpr/List (do &items loc))
        )) as (& void)}
    ))
))

(fn Lole/Parser/skip_space [(&self (& Lole/Parser))] void (
    {res : Lole/Parser/CharAtResult}

    (loop (
        {res = (Lole/Parser/current_char &self)}
        (if (not {res . ok}) (return))
        (if (not (Lole/Parser/is_space {res . data})) (break))

        (Lole/Parser/next_char &self)
    ))

    (if {res . ok && {res . data != (char_code ";")}} (do
        (return)
    ))
    (Lole/Parser/next_char &self)

    (loop (
        {res = (Lole/Parser/current_char &self)}
        (if (not {res . ok}) (return))
        (if {res . data == (char_code "\n")} (break))
        (Lole/Parser/next_char &self)
    ))

    (if {res . data == (char_code ";")} (do
        (Lole/Parser/next_char &self)
    ))

    (Lole/Parser/skip_space &self)
))

(fn Lole/Parser/next_char [(&self (& Lole/Parser))] void (
    {&self -> index += 1}

    {res := (Lole/Parser/current_char &self)}
    (if (not {res . ok}) (do
        (return)
    ))

    (if {res . data == (char_code "\n")} (do
        {&self -> col = 0}
        {&self -> line += 1}
        (return)
    ))

    {&self -> col += 1}
))

(struct Lole/Parser/CharAtResult
    (ok bool)
    (data u32) ; u8 | (& CompileError)
)

(fn Lole/Parser/current_char [(&self (& Lole/Parser))] Lole/Parser/CharAtResult (
    {chars := {&self -> chars}}

    (if {&self -> index >= {chars . size}} (do
        (return (Lole/Parser/CharAtResult
            :ok false
            :data {(Lole/Parser/err_unexpected_eof &self) as u32}
        ))
    ))

    (return (Lole/Parser/CharAtResult
        :ok true
        :data {(StringSlice/char_at chars {&self -> index}) as u32}
    ))
))

(fn Lole/Parser/err_unexpected_char [(&self (& Lole/Parser))] (& Lole/Ast/CompileError) (
    (return (new Lole/Ast/CompileError (do
        (String/from_slice "ParseError: Unexpected character")
        (Lole/Parser/loc &self)
    )))
))

(fn Lole/Parser/err_unexpected_eof [(&self (& Lole/Parser))] (& Lole/Ast/CompileError) (
    (return (new Lole/Ast/CompileError (do
        (String/from_slice "ParseError: Unexpected EOF")
        (Lole/Parser/loc &self)
    )))
))

(fn Lole/Parser/loc [(&self (& Lole/Parser))] Lole/Ast/Location (
    (return (Lole/Ast/Location
        :file_name (StringSlice/clone {&self -> file_name})
        :offset {&self -> index}
        :length {1 as u32}
        :line {&self -> line}
        :col {&self -> col}
    ))
))

(fn Lole/Parser/m_expr_to_s_expr_and_validate [(&items (& Vec<Lole/Ast/SExpr>)) (loc Lole/Ast/Location)] Lole/Parser/ParseResult (
    (if {(Vec/len &items) % 2 != 1} (do
        (return (Lole/Parser/ParseResult
            :ok false
            :data {(new Lole/Ast/CompileError (do
                (String/from_slice "ParseError: Invalid m-expr: even length")
                loc
            )) as (& void)}
        ))
    ))

    (if {(Vec/len &items) < 2} (do
        (return (Lole/Parser/ParseResult
            :ok true
            :data {(new Lole/Ast/SExpr (do
                Lole/Ast/SExpr/LIST
                (new Lole/Ast/SExpr/List (do &items loc))
            )) as (& void)}
        ))
    ))

    (return (Lole/Parser/ParseResult
        :ok true
        :data {(new Lole/Ast/SExpr
            (Lole/Parser/m_expr_to_s_expr &items loc)
        ) as (& void)}
    ))
))

; ❓ {1 + 2 - 3 * 4}
; 🚫 (+ 1 (- 2 (* 3 4)))
; ✅ (* (- (+ 1 2) 3) 4)
(fn Lole/Parser/m_expr_to_s_expr [(&items (& Vec<Lole/Ast/SExpr>)) (loc Lole/Ast/Location)] Lole/Ast/SExpr (
    (if {(Vec/len &items) == 1} (do
        (defer (Vec/free &items))
        (return {Lole/Ast/SExpr @ (Vec/at &items 0)})
    ))

    {rhs := {Lole/Ast/SExpr @ (Vec/pop_unchecked &items)}}
    {op := {Lole/Ast/SExpr @ (Vec/pop_unchecked &items)}}
    {lhs := (Lole/Parser/m_expr_to_s_expr &items (Lole/Ast/Location/clone loc))}

    {&sexpr_items := (Vec/new 3 (sizeof Lole/Ast/SExpr))}
    {Lole/Ast/SExpr @ (Vec/push_undef &sexpr_items) = op}
    {Lole/Ast/SExpr @ (Vec/push_undef &sexpr_items) = lhs}
    {Lole/Ast/SExpr @ (Vec/push_undef &sexpr_items) = rhs}

    (return (Lole/Ast/SExpr
        :kind Lole/Ast/SExpr/LIST
        :&value {(new Lole/Ast/SExpr/List (do &sexpr_items loc)) as (& void)}
    ))
))

(fn Lole/Parser/is_list_start [(char u8)] bool (
    (return {
        {char == (char_code "(")} ||
        {char == (char_code "{")} ||
        {char == (char_code "[")}
    })
))

(fn Lole/Parser/is_list_end [(char u8)] bool (
    (return {
        {char == (char_code ")")} ||
        {char == (char_code "}")} ||
        {char == (char_code "]")}
    })
))

(fn Lole/Parser/is_valid_list_chars [(start u8) (end u8)] bool (
    (return {
        {start == (char_code "(") && {end == (char_code ")")}} ||
        {start == (char_code "{") && {end == (char_code "}")}} ||
        {start == (char_code "[") && {end == (char_code "]")}}
    })
))

(fn Lole/Parser/is_space [(char u8)] bool (
    (return {
        {char == (char_code " ")} ||
        {char == (char_code "\n")} ||
        {char == (char_code "\t")}
    })
))
